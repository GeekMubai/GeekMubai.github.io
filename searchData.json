[{"title":"5 个不为人知的 PDF 技巧","url":"/5-pdf-skill/","content":"\n工作、学习中，我们都没少和 PDF 文档打交道。\n\nPDF能流行开来，功劳就在其**兼容性好**，本世纪的设备基本都能打开、打印时所见即所得、传给别人不用担心格式丢失或出错……以至于我和同事曾经调侃：**简单说，PDF 就是一张图片**\n\n不过，如果你想对 PDF 做一些超出「图片范畴」的操作，问题就接踵而至了。这篇文章里，就收集了 5 类疑难杂症，相信不少人都遇到过：\n\n1.  **PDF 边儿太宽**，浪费空间；\n2.  **PDF 里全是别人的批注**，影响我阅读；\n3.  **PDF 居然有密码**，没法在上面批注、记笔记；\n4.  **扫描版 PDF 里的字没法搜索**，只能看着它干瞪眼；\n5.  **想把 Word 文档或其他文件转换成 PDF**，一个一个来嫌太慢。\n\n这些问题遍布 PDF 的生成、传播到阅读、批注，而由于 PDF 的「图片」特性，我们没法像改 Word 文档一样轻松地修改 PDF，需要另辟蹊径。**本文将解决以上所有顽疾。**\n\n上述部分问题没有现成解决方案，所以**我会提供 3 个原创的自动化动作**。考虑到大家用的工具各不相同，我统一提供通用的 Automator 版本，安装后可以在右键菜单取用。各个第三方工具的玩家可以自行改造，做出适合自己操作习惯的动作。\n\n![](https://app.yinxiang.com/shard/s49/share/1578e-s49/res/b8be92ea-3118-455e-8511-69f15142a5a2/e999068bac65c7654159e41879975d95.png)\n\n本文所有工具都可以在右键菜单取用\n\n注：本文技巧仅供个人使用，请勿用于传播盗版资源——事实上，这些方法也入不了有批量生产需求的盗版商之眼。\n\n技巧一：去除白边\n--------\n\n「白边」是 PDF 文件的特色。有些白边是特意留出来放页码、页眉的，有些则是扫描时一同扫进去的白底1  ，但总而言之，它们挺很浪费屏幕空间，特别在 Kindle、小平板等小尺寸设备上，文字会被压缩好几圈。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/39cfccf8630ed941eccc31c77dba4e20.jpg)\n\n\n\n用 Kindle 看没裁过的 PDF，往往挺遭罪\n\n去除白边有很多思路，我们用两种 macOS 原生的。**一种是重新打印，另一种是手动裁剪**，各有优劣，我们分别介绍。\n\n### 重新打印\n\nmacOS 自带的打印功能可以按比例缩放 PDF，从而裁出比较整齐的新 PDF 文档。直接用预览工具打开 PDF 文件：\n\n1.  勾选「缩放」，填入数值。留意一下左侧预览窗口，感觉白边差不多没了就行了。\n2.  选择左下角「存储为 PDF」。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/69461f5c18a25f0b0f3c00c0dcfd46f9.png)\n\n\n重新打印\n\n重新打印后的 PDF 文件图文内容明显大了一圈，如果你需要在 Kindle 上阅读，也可以把数值填大一些，把页码一起切除。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/64306cc992de75ea308a561136f3fa93.png)\n\n\n打印后白边小了很多\n\n不过打印的缺陷也比较明显，需要 PDF 本身比较规整，可很多扫描版 PDF 的白边分布很随机，没法通过打印通吃它们2  ，这时候就需要手动裁剪了。\n\n### 手动裁剪\n\n听到「手动」两字不用怕，**其实还是可以批量处理的**。仍然用预览工具打开 PDF：\n\n1.  点击左上角的按钮，开启「缩略图」视图；\n2.  按下 `⌘Command - A`，选中所有页面；\n3.  点击「菜单栏 \\- 工具 \\- 矩形选择」；\n4.  选中需要留下的区域，按 `⌘Command - K` 进行裁剪。\n\n手动裁剪 PDF\n\n裁剪前可以发现，尽管只在 PDF 其中一页进行了选取，但选区被应用到了所有页面——因为我们已经提取选中了它们，**从而实现批量处理**。开一方面，相比重新打印，裁剪还可以更灵活：\n\n1.  选区能自行调整，不一定非得是 A4 纸3 的长宽比；\n2.  如果部分页面如果裁不齐，可以单独再行修剪。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/6b20ae1126955fdb5bf128906448dd6c.png)\n\n\n手动裁剪时，不同页面可以裁成不同大小\n\n不过手动裁剪也有问题，**首先就是很难裁整齐。**如果你的阅读器能够显示 PDF 封面（基本都能显示，逃不掉的），那你将获得一排参差不齐的书籍封面，看着很碍眼。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/f58f5459a2ea4ab0850b20b94af46f23.jpeg)\n\n高低不齐的封面看着很难受\n\n另外，扫描版的 PDF 文件往往体积巨大，动几十上百兆，而裁剪操作仅是隐藏边上的部分，并没有删除它们，**裁好后文件体积不会减小**。\n\n**总之，如果想裁得整齐、精巧，又不在意目录，那可以重新打印；如果需要保留目录，那还是手动裁剪。**\n\n技巧二：去除批注\n--------\n\n有些 PDF 流传了几代，交到我们手里时已经画满了前人的标记。这些用功的痕迹，很大程度上也影响了正常的阅读、批注。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/5368e3972f33c21ea41f02029c04df2c.png)\n\n\n画满了批注的PDF\n\n虽说 PDF 可以看作一张「图」，但它可能也是分层的，批注就是最顶端的「图层」，能够选中后删除。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/1add4a4b2f886e89d34ae8b9da3fbcce.png)\n\n\nPDF 其实是分层的\n\n不过文档里的批注出没无常，就算有耐性一个一个手动删，也不一定拔得干净。PDF Expert、Adobe PDF Acrobat 这些专业工具倒是能够批量消灭批注，但它们价格实在太高，这里介绍一个不花钱的工具：**iOS 上的 PDF Viewer**。\n\nPDF Viewer 是那种讨人喜欢的小巧阅读器，原生界面，简单的导入导出功能、必要的批注工具，最重要的是可以导出纯净版 PDF，不含标注。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/89026d16fd0941542cf2ed6a8c4b3844.png)\n\n\nPDF Viewer 可以导出不带批注的 PDF\n\n没有多余的步骤，一份干净的 PDF 就出现了。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/343fa9c89a0082b02b1f7ed427422afe.png)\n\n\n去除批注前后\n\n对了，如果你下载了一份插满推广链接的 PDF——尤其是那种不小心碰一下就会弹到浏览器的烦人链接——上述方法或许也能起到批量清理作用。\n\n技巧三：绕过编辑密码\n----------\n\n**有些 PDF 能打开阅读，但是不能编辑，做笔记也不行，很头疼。**这就是遇到拥有者密码（Owner Permission Password）了。\n\n初衷是好的，但有时也会给自己人带来不便。读书时就有这种情况，系里祖传的一些 PDF 书籍，当年的制作者不知何处高就去，只留密码挡我路，在我们看到精彩处、大笔一挥想记点东西时，发现没有权限编辑。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/c380eaad4ddbd1b9d5d0cd03a40fb7be.png)\n\n编辑密码严重影响做笔记\n\n好在这类编辑密码也有办法绕过的：不用什么「破解」，**只需要一个 Google Drive 网盘**。\n\n1.  先确认一遍，你遇到的的确是拥有者密码，如果连打开都不给打开，你还是找提供 PDF 的人讨密码吧；确认后，**把想编辑的 PDF 文档上传到 Google Drive**。到这一步，事儿就成了一半了。\n    \n ![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/53cfd6fd1a551aa39a8212c4e0c9ae3e.png)\n\n\n    \n    上传 PDF 到 Google Drive\n    \n2.  接着就省力了，在 Google Drive 里点击查看 PDF，**点击右上角的打印按钮**，静待一分钟，不带密码的 PDF 就生成了，Google Drive 会帮你打开一个预览的页面。\n    \n    ![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/66bd82704e13e2c0fccccade6b3ec4b0.png)\n\n    \n    在 Google Drive 中打印 PDF\n    \n3.  **最后点击预览界面的下载按钮**，新 PDF 就躺在了你的下载文件夹。如果没看到下载按钮，就在页面中下方晃几下鼠标把它召唤出来。\n    \n    ![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/98ec498aee043ac7285c81797febe644.png)\n\n    \n    下载没有密码的 PDF 到本地\n    \n\n说到底，这个技巧的原理只是把你看到动东西重新打印了一遍，其他网盘或在线文档协作工具可能也支持，大家不妨自己测试一下，如果有能在国内可用的服务就更好了。\n\n之前坊间流传过用 Chrome 浏览器重新打印来「解锁」密码的方子，不过在最新版本的浏览器中已经失效。我做了些测试，当前版本的 Chromium、Firefox、Safari 等浏览器均无法直接打印带密码的 PDF。\n\n此外，网上还有一些破解 PDF 密码的站点，需要上传原始 PDF 文件，无论出于版权还是安全因素考虑，这里并不推荐4  。当然，如果是一些从不可言说网站下载来的 PDF，连解压/打开密码都不知道，那就无能为力了\n\n技巧四：将扫描版 PDF 转换成可搜索的文档\n----------------------\n\n读过扫描版 PDF 的人，都知道那种**能看不能搜**的感觉是多么难受。不巧，有些老教材又只有扫描版，似乎只好硬着头皮人肉检索。\n\n@契丹神童 曾经在 Power+ 1.0 介绍过 [ocrmypdf](https://pypi.org/project/ocrmypdf/) 这个命令行工具，**能够给扫描件填上一层文字层，使得文本能够被搜索**；我据此做了一个 Automator 动作，这样，不用买第三方工具也可以享受 OCR 功能。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/37d1d39a90204882337480f7b09f0f93.png)\n\n\nocrmypdf 处理过的文件能被搜索\n\n[\\> 动作下载](https://cl.ly/13501bd4b000)\n\n光装好动作，还不能直接用，需要安装和配置一下 ocrmypdf。**下面是安装 ocrmypdf 及中文语言包的脚本，直接复制到终端中运行即可。**截至写这篇文章，tesseract 的最新版本是 3.05.02，如果下载语言包失败，请到 `/usr/local/Cellar/tesseract/` 下检查一下你的版本是多少，并把命令里的旧版本号 `3.05.02` 替换掉。\n\n```\n    # 安装脚本\n    brew install ocrmypdf\n    wget -o /usr/local/Cellar/tesseract/3.05.02/share/tessdata/chi_sim.traineddata https://github.com/tesseract-ocr/tessdata/raw/master/chi_sim.traineddata\n```    \n\n装好动作、配置完成后，OCR 功能就会出现在右键菜单里。\n\n挑一个扫描版或图片版本的 PDF 识别一下，短则几秒钟，长则几分钟，具体要看 PDF 大小。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/b0e779b1282c96f247cf84bb30fd619a.png)\n\n\nOCR 功能在右键菜单里\n\n动作运行结束后再打开 PDF，就能进行搜索了。其实不光在 PDF 文档里面可以搜索，直接用 Spotlight、Finder 也能搜刚才处理过的 PDF，很方便。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/64eeeed7d421f669fa9d92128e30093f.png)\n\n\n通过 Spotlight 搜索到了 ocrmypdf 处理过的文件\n\n除了右键菜单，刚才你下载的 Automator Workflow 还可以当作快速操作来用，直接在 Finder 的 PDF 预览面板里进行 OCR 识别。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/01729d9112a160d1c98d712e8302aad9.png)\n\n\n把 OCR 动作集成到 Finder\n\nocrmypdf 的功能非常强大，我只用到了其中的中文和英文 OCR 功能，如果你还要和其他语种打交道的话，不妨读读契丹神童的文章，试着自己配置语言包。\n\n\n技巧五：批量制作 PDF\n------------\n\nPDF 最「本职」的工作，估计就是作为一种万能的打印格式。不少人都有给文印店 PDF 文档的好习惯，即便店里设备再古董，打印出来格式也不太会出错。\n\n不过对于制作 PDF 的人来说，可能就要花点力气了，遇上期末、项目截止时文档较多，还挺麻烦。**下面的两个自动化方法可以一次性把各类常见文档转换成 PDF，方便打印。**\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/426ef75f890bf0c2d671c1da206da1c4.png)\n\n\n\n3 类文档的转换流程\n\n### 文本文档转换成 PDF\n\n不含图片的文档主要有 3 类 ：\n\n1.  Docx 文档\n2.  HTML 文件\n3.  RTF 富文本文件\n\n它们转换起来比较容易，在 macOS 上不用下载任何第三方工具，全靠系统工具就能解决。动作我已经做好，大家可以直接下载，解压后双击安装到右键菜单就能用了。\n\n将文本文档转换为 PDF\n\n[\\> 动作下载](https://cl.ly/74ce1d473a05)\n\n注：本动作对于 RTF 和 HTML 文件支持良好，部分在 Docx 文档可能丢失格式。\n\n稍微留意上面的视频，你会发现，**我这个动作不仅可以批量转换 PDF，而且 3 类文档通吃，一起选中也照样处理掉**。其实背后的原理挺简单的，就是根据不同文件格式、套用不同的系统命令6  。具体的代码我们不展开，只需简单了解一下上面 3 类文件的转换过程，以后遇到需要转格式的情况，你也可以对症下药：\n\n1.  Docx 文档：先用 `textutil` 命令生成 HTML，再用 `cupsfilter` 命令转换成 PDF。\n2.  RTF 文件：先用 `textutil` 命令生成 HTML，再用 `cupsfilter` 命令转换成 PDF。\n3.  HTML 文件：直接用 `cupsfilter` 命令转换成 PDF。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/fb6f15d7738060cb869d5e522fc56e69.png)\n\n\n各种格式的文章转换成 PDF\n\n### 含图片的文档转换成 PDF\n\n如果是嵌有图片的文档，上面的方法就不起作用了，不过我们仍然有一个原生方案。\n\nmacOS 的老玩家可能还记得，可以安装 Office 套件，然后搭配 Automator 实现 Word 到 PDF 的转换。**其实有个很取巧的办法，完全用不着 Office，用免费的 Pages 就可以生成 PDF，而且通吃 Docx 和 Pages 文档。**\n\n和前几节一样，这次动作还是 Automator Services，装好后同样会出现在右键菜单里。**一次性选中几个 Docx 和 Pages 文档，然后运行这个动作，稍等一会儿几份 PDF 就导出来了。**\n\n将含图片的文档转换成 PDF\n\n[\\> 动作下载](https://cl.ly/8d309b86f69e)\n\n就像视频所演示的，只要你愿意，Docx 和 Pages 文档混着一起转换也行，照样能够打印成功。\n\n动作原理并不复杂，只是把日常的「导出」操作写进了 AppleScript 脚本里面；有意思的地方在于，Pages 是可以打开预览（但是一些 Word 专有样式会丢失）Docx 文档的，所以不需要进行任何优化就可以让 AppleScript 像处理原生 Pages 文档一样打印 Docx——反正就是所见即所得嘛，没有什么深奥的东西。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/c8162d54b180942fbab8c4ac90a29a64.png)\n\n\n通过 Pages 打印带图片的文档\n\n小结\n--\n\nPDF 固然是一种方便的预览格式，而「看」以外的操作，往往不是它的特长。条件允许的话，应该选择 Word、Markdown 等更适宜的文档格式。\n\n由于种种原因，我们仍然需要用到 PDF，而且涉及从页面调整到文本搜索等不属于其本职的操作。遇到这些情况，就需要一些巧劲儿了。\n","tags":["pdf"],"categories":["教程"]},{"title":"在 Windows 上享受更棒的字体渲染","url":"/better-font-on-win/","content":"\nWindows 的字体渲染问题一直是一个老大难，每隔一段时间就会有人吐槽 Windows 的字体有多难看、macOS 的字体又有多美观。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203203949.png)\n\n实际上，微软在这方面并非毫无作为，而是进行过多次优化。但由于软硬件上的种种限制，让广大群众至今没能真正享受到高质量的字体渲染效果。\n今天就让我来带大家仔细讲讲 Windows 的字体渲染为什么这么差，以及如何用稳定的方法解决字体渲染问题。\n\n## Windows 的字体渲染问题出在哪里？\n长期使用 macOS 的用户可能无法理解 Windows 用户到底在发什么牢骚。\n为了有一个直观的感受，我在 Windows 和 macOS 中各截取了一些文字。对比一下下面这两段文字，就会发现它们的实际观感区别很大。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204101.png)\n> macOS 下的字体\n\n将 macOS 下的文字放大后观察，字体美观、边缘厚实，一笔一划很是清晰。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204244.png)\n\n>Windows 10 下的字体\n\nWindows 的字体只能算是能够看清，但边缘总有些发虚，对比之后则略逊一筹。放大后观察，边缘有一些红绿小色块，「安」字中间的一横显得颜色很深，整体多少有些不协调。\n而出现这种情况的原因有很多，我总结了以下 3 点——\n\n### 屏幕显示分辨率低\n屏幕的显示分辨率是首当其冲的问题。\n为了描述这个问题是怎么出现的，除了屏幕本身的分辨率和尺寸之外，我们还需要了解显示器的一个重要参数：PPI（Pixels Per Inch），指的是「每英寸的像素数量」。\n我们可以用一个公式来计算出屏幕的 PPI：√(纵向像素数² + 横向像素数²) / 屏幕尺寸\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204350.png)\n\n比如一块 1920 x 1080 的 15.6 寸显示器，它的 PPI 就是 √(1920² + 1080²) / 15.6 = 141.21。从这个公式中可以看出「同等分辨率的屏幕越大，PPI 就越低」。\n如果我们想在屏幕上显示文字，就需要在像素点阵中填充内容。比如你想在 12 x 12 的点阵下塞进一个中文汉字，只用黑白两色填充就只能得到图中的点阵文字。只有换成一个更大的点阵，笔画之间才会有空间填充更多的笔画细节，从而使笔画之间变得更为顺滑。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204432.png)\n\n近些年出产的 Mac 都配备上了 Retina 屏幕，分辨率从 2560 x 1600 到最高的 5120 x 2880 不等，PPI 可以达到 227。实际使用时，macOS 通常会采用缩放，让一块高分辨率的屏幕显示更多的内容，文字自然会变得更加清晰。\n而 Windows 方面，仍然有大量的电脑在使用 1920 x 1080 的分辨率和更低分辨率的显示器，大多数万元以下的笔记本配备的也是 1080P 甚至是 1366 x 768 的显示器。一块 15.6 寸的 1080P 屏幕，PPI 只能达到 141 上下。相比高 PPI 的 Mac，Windows 的文字显示自然比不过它。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204449.png)\n\n所以，屏幕分辨率属于 Mac 天然的硬件优势。\n\n### 字体问题\n\n第二个问题在于字体。 字体的字形不同，也会影响字体的显示效果。\n比如在 Word 中使用四号宋体，边缘会显得模糊，而小四、五号等字号时，边缘则十分锐利。即使直接在 Word 中使用苹方字体，边缘也会出现一定的模糊。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204521.png)\n\n这种进行模糊处理的方式，其实是 **Windows 对于低分辨率屏幕下字体显示进行的特殊处理：Hint**。每个字体本身会带有一个 GASP 表，Windows 的渲染引擎会根据这些 GASP 表来判断是否需要做处理。\n当屏幕分辨率过低或是字太小，不足以显示所有文字细节时，Windows 就会启动 Hint 让文字变得更清晰，这本来是一件好事。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204553.png)\n\n然而如果字体的 GASP 表不完善，就会让 Hint 误操作，本来就是可以正常显示字体的高分屏，但经过 Hint 处理过后，原本清晰的字体反而变得模糊、笔画高低不平了，这就是字体本身的问题。\n这个问题曾出现在 Windows 的默认字体微软雅黑上。如今最新版的 Windows 10 中内置的微软雅黑已经进行过优化，比以前要好很多了。\n\n### 渲染方式问题\n\n如果排除上面两个因素，最后的问题就是系统的文字渲染方式了。\n粗略地讲，Windows 目前采用三种不同的渲染方式，它们之间是相互补充的关系，同时存在于系统中。\n* GDI+（Graphical Device Interface）：GDI 渲染指的是图形设备接口，属于 Windows 的核心组件之一。GDI 的历史很悠久，许多年迈的 Win32 软件都采用 GDI 来渲染字体。GDI+ 是它的改进版。\n* ClearType：为了提升 LCD 屏幕的字体渲染效果而推出的改进功能，也是目前 Win 10 主要采用的字体渲染方式。准确地讲这并不是渲染引擎，称为字符平滑工具、抗锯齿功能更为合适。\n* DirectWrite：为了提升高分辨率屏幕的字体渲染做的优化引擎。需要开发者做支持，全面进入 DirectWrite 时代还需经历时日。目前主要是 UWP 应用在使用。\n其中的传统字体渲染引擎 GDI 很老，采用 GDI 的 Win32 软件在高分辨率屏幕下使用 100% 之外的缩放就会出现模糊。但由于采用 GDI 的软件实在太多，牵一发而动全身，微软无法轻易换掉 GDI。\n于是 ClearType 便应运而生。ClearType 的原理是让显示器的 R , G , B 次像素放光，在 x 和 y 轴上增加一些颜色进行微调，使得文字更清晰。\n\n不过这尚未真正解决问题，在 Windows 10 默认启用 ClearType 的情况下，文字表现依然不佳。最前面的对比图中，Windows 的文字边缘就有这种红绿小色块的身影。在低分屏下，这种小色块会让文字边缘显得「有些糊」，中文的笔画也会有深有浅。\n\n**于是微软又推出了新的 DirectWrite 引擎，它就是为了取代 GDI 和 GDI+ 而诞生的。**它的渲染方式已经和 iOS、Android 上采用的 FreeType 引擎效果接近，只是我们日常用的许多老软件未做适配。所以这也是为什么 UWP 应用的字体渲染会比 Win32 软件看起来要好一些的原因。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204703.png)\n\n如果做一个形象的比喻，那么 GDI 就是年迈的老人，ClearType 就是一副眼镜，DirectWrite 则是更能干的接班人。\n可以发现，字体渲染方式的问题其实是多方面的，根源就在于 GDI 的老旧、ClearType 的不完善、软件不跟进 DirectWrite 这些问题上。这几个渲染方式会影响到优化时的一些操作，我们后面还会提到。\n\n## 如何搞定渲染\n\n了解字体渲染效果差的原因之后，我们可以发现 Windows 的字体渲染问题还不少，这些问题可以有很多种解决方法，括号中是解法的简单概括——\n* 显示器分辨率过低（更换硬件）\n* 老软件适配差（Win32 应用、单独调整）\n* 字体本身产生模糊（更换字体、修改字体本身）\n* 字体丑，想换字体（更换字体）\n* 渲染时产生的模糊（更换渲染引擎）\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204733.png)\n\n明确了问题和产生问题的原因，那我们就根据这几个问题来分别做出对应的优化。\n下面我从简单到复杂，介绍多种优化字体渲染的方法。由于没有人会愿意因为美观而舍弃系统的稳定性，所以在下列方法中，不会出现改动注册表、手动修改系统文件的方法，稳定性 永远是第一要素。\n\n### 解决显示器分辨率过低、老软件适配差问题\n\n其中显示器分辨率属于硬件问题，想一劳永逸地解决问题，可以选择购置 2K 分辨率以上的显示器，Windows 在高分屏上的字体渲染表现不俗。然而，考虑到 2K 显示器「同样不俗」的价格，大部分人还是会选择在现有的硬件资源上进行软件优化。\n如果想在现有的硬件上做优化，最简单最安全的方法自然是 Windows 内置的方案了。\n\n#### 直接修改缩放\n在 Windows 中提供了一个简单的「缩放功能」来放大系统的界面。它的效果是让一个文字获得更多的像素点。从而获得更好的视觉体验。\n在「设置 - 系统 - 显示 - 缩放与布局」中调整「更改文本、应用等项目的大小」，从 100% 到 200% 不等。这些选项中 Windows 会给出一个推荐选项，可以选择适当提升一档。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204830.png)\n\n如果你觉得 200% 的缩放仍然不够，「高级缩放设置」中允许你调整到 100% - 500% 之间的任意数字。不过一般不建议改动这一项。\n\n#### 修改单个应用的缩放\n不过调整缩放之后，会让一些对 DPI 缩放支持较差的老应用出现严重模糊，像是老版本的迅雷、QQ 等软件。这时候可以单独调整应用的缩放。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204859.png)\n\n在软件的快捷方式上右键，打开属性菜单。如果是在任务栏上的软件，「右键图标 - 右键菜单中的名称 - 属性」就可以进入属性设置界面。\n然后在「兼容性」选项卡中，选择「更改高 DPI 设置」，选中「替代高 DPI 的缩放行为」。其中的 应用程序 指的是让软件保持 100% ，系统 指的是根据系统设置的缩放比例来调整（可能会变得模糊），系统（增强） 会对那些基于 GDI 渲染方式的软件进行更多的优化。\n所以如果遇到了上面的问题，你可以选择使用 应用程序 或是 系统（增强） 来做一些特殊调整。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204930.png)\n\n#### 修改字体大小\n如果你目前正在使用的就是高分辨率的屏幕，反而觉得有些字太小、看不清。又不想调整所有界面的缩放，那就可以根据需要单独调整文字的大小。\n在「设置 - 轻松使用 - 显示 - 放大文本」中调整滑块，然后选择「应用」。\n之后电脑会进入半分钟左右的等待时间，结束后，Windows 中的所有文字都会被放大一些，文字的观感也会有所提升。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204959.png)\n\n这三种方法都是 Windows 内置的方法，经过简单且安全的操作，就可以让我们在分辨率稍低的显示器上获得较好的文字观感。同时解决了一部分老软件的适配问题。\n\n### 解决字体本身产生的问题\n如果调整了屏幕缩放，文字依然模糊。那就需要解决字体问题了。替换字体有两种思路：\n1. 更换字体：用别的字体作为默认字体。 对系统造成的破坏最小，随时可以改回来。\n2. 修改字体：对默认的微软雅黑进行处理。 对微软雅黑进行处理，让它获得更好的视觉效果。\n全局更换字体的简单方法\n更换系统字体有许多方法，小软件、小工具也不少。这里推荐一个来自日本开发者的「全局字体更换」开源小工具：noMeiryoUI，noMeiryoUI 的特点是针对亚洲字符集字体做了优化。软件可以在 Github 链接 下载。\nnoMeiryoUI 的操作和使用都非常简单。你只需要事先找到并安装一个适合日常使用的字体，要避免选择缺胳膊少腿的字体，以免改完后出现许多 □ □ □。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203205101.png)\n\n然后就像在编辑器里修改字体一样，点击 `Select...` 直接指定系统全局所用的字体和字号大小。选择字体时，同一个字体可能会有多种字符集（简体、繁体、日语等），这在 noMeiryoUI 中可以单独选择。当然也可以分别对标题栏、图标、调色板标题、提示、消息框、菜单的字体和字号进行单独设置。\n然后选择` Set All `就可以替换完成。\n\n经过 noMeiryoUI 替换字体后，大部分 Win32 软件（包括系统软件在内）改变默认的字体和字号。noMeiryoUI 无需开在后台，一次替换就能长期使用。\n为了展现替换效果，我选择了和系统字体差别明显的幼圆字体。软件中采用 DirectWrite 渲染的部分文字是无法替换的，菜单则被完整替换了。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210357.png)\n\n### 修复字体 Hint 模糊的方法\n\n字体模糊的情况通常在采用 125% - 200% 缩放比例的情况下发生。所以修复微软雅黑、宋体等系统默认字体本身产生的模糊，也是一个可行的方案。\n上面讲到由于错误的 GASP 信息产生了不正确的 Hint，那么禁用 Hint 就能让文字变得更锐利一些。大致的思路是：使用批处理脚本处理系统默认字体的 GASP 信息、进入命令行模式（解除字体占用）、将处理后的字体覆盖原字体。\n这个操作与换一个字体作为系统字体不同，它会修改并替换系统字体文件本身，在未做备份的情况下替换字体可能会产生一些不可预料的后果（字体显示问题、蓝屏等）。所以安全性和兼容性比较一般，不是很推荐。不过它可以解决 DirectWrite 模式下的 Hint 模糊问题，需要的读者可以进入该链接按步骤操作。\n\n### 解决渲染时产生的模糊\n如果调整缩放、修改字体都没有缓解字体模糊，就需要采取一些其他手段来解决字体渲染引擎产生的模糊。\n\n#### 更换系统字体渲染引擎：MacType\n更改字体渲染引擎是一个庞大的工程，只要是有文字的地方就会用到字体渲染，牵一发而动全身，不得不慎重。\nWindows 上表现出色的字体渲染软件是 MacType，它可以帮助改善 Windows 中基于 GDI 的字体渲染，并支持热替换系统的默认宋体。你可以在它的 Github 链接 下载到 Beta 版本。\n\n#### MacType 的加载方式\n下载并安装后，MacType 会进入一个用户向导界面，你可以自主选择 MacType 的加载方式。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210526.png)\n\n这几种加载方式的优缺点已经在软件界面中详细说明，如果要概括一下：\n* 注册表加载：体验最好，开关需要重启系统。\n* 服务加载：平滑度较高，开关需要使用服务管理器。\n* 不使用自动加载：拖动到图标上加载，可以只针对特定渲染效果较差的软件修改。\n* MacTray 托盘独立加载：可以单独设置一些应用是否渲染。\n* MacTray 托盘兼容加载：兼容性最好。\n\n如果想要全局使用，我个人比较推荐服务加载，软件不会影响到注册表，停用时比较方便。\n如果只是想针对个别软件进行字体优化，则推荐 MacTray 托盘独立加载。\n这些加载方式各有优缺点，大家可以衡量一下自己对于美观度和稳定性的要求，来选择最适合自己的方法。\n\n#### MacType 的配置文件\n如果你不想做过多的配置，直接使用第二步中预设的默认配置文件，点击完成就配置完毕了。如果对这个配置的渲染效果不满意，可以多试几个，也可以自行配置文件。在网络上也有不少 MacType 相关的字体和配置文件。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210616.png)\n\n不过 MacType 的功效仍然是有限的，它不支持采用 DirectWrite 字体引擎的软件（主要是 UWP 应用）。你需要做更多的配置才能实现。\n\n#### MacType 的其他注意事项\n尽管 MacType 的效果已是十分喜人，但它作为第三方软件，仍然不可避免地出现一些问题。\n它的兼容性一般，它在大部分情况下都能正常运作，但在部分软件、游戏、驱动程序中会出现错误的文字渲染，比如一整行文字挤在一起。如果追求工作环境的稳定，则不建议使用 MacType。如果你在安装 MacType 之后，一些原先可以打开的软件忽然打不开了，一定要记得在 MacType 中排除这个软件。\n顺带一提，目前 Chrome 会默认开启 DirectWrite 且不可关闭，这种情况下使用 MacType 偶尔会产生冲突。网上有许多人求禁用 Chrome 中 DriectWrite 的方法，其实没有这个必要。只需要在 MacType 中关闭针对 Chrome 的渲染，并在 Chrome 中修改浏览器显示字体就可以了。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210828.png)\n\n## 小结\nWindows 的字体渲染问题并非是微软完全不作为，因为在的 Windows 10 1703 和 1809 中，字体方面都得到了小幅度的改进，微软雅黑这个字体本身也经历了多次迭代，还有传闻称今年四月份微软将会用兰亭黑体替换掉微软雅黑。但在目前，Windows 渲染效果差仍然是个不争的事实。\n文章对产生这个问题的原因进行了分析，显示器分辨率，系统默认字体，老的引擎难以淘汰、新的引擎未能覆盖……但只要对症下药，这些问题都是可以解决的。分别从分辨率、字体、渲染引擎几个角度下手，就能搞定 Windows 的字体渲染问题。\n\n\n","tags":["windows","字体","美化"],"categories":["教程"]},{"title":"Syncthing就是我要的同步备份软件","url":"/syncthing-the-best/","content":"\n[](#引言 \"引言\")引言\n--------------\n\n数据无价，平时不注意备份，电脑突然翻车就追悔莫及啦。\n\n最开始的时候，我在路由器上开启 Samba，每次编辑完项目就手动拷贝到路由器硬盘里，麻烦程度可想而知，后来又用了 Google Drive/One Drive，又因为它们的网络不理想，就又放弃使用了。\n\n其实就是很简单的需求，自动备份、速度快，然后去找了一下，发现一堆人推荐用 Rsync，这货我只在 VPS 上用过，拿来做镜像同步，但是要做实时同步，不好配置。\n\n我就想，这需求应该有一大堆人有吧，就去 github 搜索 sync，发现 Syncthing 这么个好东西，截止 2018-06-13 已经得到 20k+ 的 star，并且更新很活跃\n\n[](#介绍 \"介绍\")介绍\n--------------\n\n![logo](https://pic.zhih.me/blog/posts/syncthing-the-best/logo.jpg)\n\nSyncthing 是一个文件连续同步软件\n\n项目地址：[https://github.com/syncthing/syncthing](https://github.com/syncthing/syncthing)\n\n它有以下特性：\n\n*   跨平台\n    \n    *   使用 Golang 开发，几乎能在所有平台上使用，包括常见的安卓手机和路由器平台\n*   易于使用\n    \n    *   只需要下载运行，打开浏览设置本地目录和远程主机，其他的不需要管\n*   安全\n    \n    *   管理页可以设置密码，可以设置 https，设置备份需要两边都确认，使用唯一设备标识进行确认\n\n[](#安装 \"安装\")安装\n--------------\n\nSyncthing 有多种安装方式\n\n有一定 Linux 基础的人，可以使用下面的配置来设置启动服务\n\n*   [https://github.com/syncthing/syncthing/tree/master/etc](https://github.com/syncthing/syncthing/tree/master/etc)\n\nWindows，Mac，Linux 和安卓手机可以在这里下载有 GUI 界面的程序使用\n\n*   [https://docs.syncthing.net/users/contrib.html#gui-wrappers](https://docs.syncthing.net/users/contrib.html#gui-wrappers)\n\n其他方法可以自己决定，我是直接下载安装包命令行启动的\n\n### [](#在-MacOS-上安装 \"在 MacOS 上安装\")在 MacOS 上安装\n\n我用的是 MacOS，可以直接使用 homebrew 安装启动，并且可以开机自动启动，你也可以到这里 [QSyncthingTray](https://github.com/sieren/QSyncthingTray/releases) 下载 MacOS 的 GUI 版\n\n```\nbrew install syncthing  \n```\n\n启动服务（同时设置开机启动）\n\n```\nbrew services start syncthing  \n```\n\n停止服务（同时关闭自启）\n\n```\nbrew services stop syncthing  \n```\n\n手动启动（不会开机自启）\n\n```\nsyncthing  \n```\n\n启动进程后，可以用浏览器打开 `http://localhost:8384/` 来查看 web 管理页\n\n### [](#在-Windows-上安装 \"在 Windows 上安装\")在 Windows 上安装\n\nWindows 直接在这里 [SyncTrayzor](https://github.com/canton7/SyncTrayzor/releases) 下载软件运行\n\n### [](#在-Linux-VPS-上安装 \"在 Linux VPS 上安装\")在 Linux VPS 上安装\n\n大多数发行版和不同 CPU 平台的安装包，可以在这里 [Syncthing](https://github.com/syncthing/syncthing/releases) 找到，把它下载到你想要放在的目录然后设置权限，使用命令运行\n\n文章开头有 GUI 版本的链接，不过我要装在没有 GUI 的 VPS 上，所以直接用命令行运行，系统用的是 Debian 9，然后用 supervisor 进程守护来启动的\n\n碰巧前几天之前的一个客户，他的 VPS 做迁移，阿里云送了张代金券，然后客户就送给我了\n\n![aff](https://pic.zhih.me/blog/posts/syncthing-the-best/aff.jpg)\n\n然后续费 9 个月的阿里云学生机，美滋滋😎\n\n虽然带宽比较低，但是对于这种连续同步的备份来说，在第一次备份之后，后面都是增量备份了，除非你都是备份大文件，要不对带宽的要求不是很高，另外 40G 的盘，完全够我备份用了，阿里云最主要就是稳定，很适合做我的备份机\n\n#### [](#下载-Syncthing \"下载 Syncthing\")下载 Syncthing\n\n下载最新的包，解压，移动到 `/bin/` 里，改权限\n\n```\nwget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \ntar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \nmv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /bin/  \n  \nchmod +x /bin/syncthing  \n```\n\n#### [](#进程守护 \"进程守护\")进程守护\n\n安装 supervisor\n\n```\napt-get install supervisor  \n```\n\n配置守护\n\n```\nvi /etc/supervisor/conf.d/syncthing.conf  \n```\n\n填入以下内容\n\n```\n\\[program:syncthing\\]  \ncommand = /bin/syncthing -no-browser -home=\"/root/.config/syncthing\"  \ndirectory = /root  \nautorestart = True  \nuser = root  \nenvironment = STNORESTART=\"1\", HOME=\"/root\"  \n```\n\n**注意**，我例子里使用的是 root 用户，所以响应的目录是 `/root`，你要是使用其他用户，应该是 `/home/用户名`，就是你登录时默认所在的目录\n\n现在就可以使用 `supervisorctl` 命令来管理进程了\n\n*   启动\n\n```\nsupervisorctl start syncthing  \n```\n\n*   重启\n\n```\nsupervisorctl restart syncthing  \n```\n\n*   停止\n\n```\nsupervisorctl stop syncthing  \n```\n\n启动进程后，可以用浏览器打开 `http://你的IP:8384/` 来查看 web 管理页\n\n如果无法打开页面，需要修改 `/.config/syncthing/config.xml` 里的 `127.0.0.1:8384` 字段为 `0.0.0.0:8384`，或者你可以和我一样使用 nginx 做反向代理，前提是你知道怎么做\n\n### [](#在路由器上安装 \"在路由器上安装\")在路由器上安装\n\n目前 [Entware](https://entware.net/) 源里已经有这个包了，但是我发现它是个旧版本，并且有问题，所以这里我选择手动安装\n\n这里的例子是 LEDE x64 但是也适合一切安装了 Entware 的路由器\n\n在这里 [Syncthing](https://github.com/syncthing/syncthing/releases) 下载对应 CPU 平台的安装包，可以用 `uname -m` 查看，我这里是 x86_64 所以选择 amd64\n\n#### [](#下载-syncthing \"下载 syncthing\")下载 syncthing\n\n下载最新的包，解压，移动到 `/opt/bin/` 里，改权限\n```\nwget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \ntar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \nmv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /opt/bin/  \n  \nchmod +x /opt/bin/syncthing  \n```\n#### [](#添加启动命令 \"添加启动命令\")添加启动命令\n\n创建并编辑 `/opt/etc/init.d/S92syncthing`\n```\nvi /opt/etc/init.d/S92syncthing  \n```\n在里面填上下面所有字段\n\n```\n #!/bin/sh  \nENABLED=yes  \nPROCS=syncthing  \nARGS=\"-home=/opt/etc/syncthing\"  \nPREARGS=\"\"  \nDESC=$PROCS  \nPATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin  \n  \nif \\[ ! -d /opt/etc/syncthing \\]; then  \n /opt/bin/syncthing -generate=\"/opt/etc/syncthing\"  \n sed -i 's|127.0.0.1:8384|0.0.0.0:8384|' /opt/etc/syncthing/config.xml  \nelif \\[\\[ -f /opt/etc/syncthing/config.xml -a \"127.0.0.1:8384\"==\"127.0.0.1:8384\" \\]\\]; then  \n sed -i 's|127.0.0.1:8384|0.0.0.0:8384|' /opt/etc/syncthing/config.xml  \nfi  \n  \n. /opt/etc/init.d/rc.func  \n```\n然后给权限\n```\nchmod +x /opt/etc/init.d/S92syncthing  \n```\n用法: /opt/etc/init.d/S92syncthing (start|stop|restart|check)\n\n启动服务就能在浏览器打开 `路由器IP:8384` 例如 `192.168.1.1:8384` 打开管理页了\n\n[](#使用方法 \"使用方法\")使用方法\n--------------------\n\n易于使用是 Syncthing 的一个重要特性，打开管理页，一目了然\n\n首次打开管理页，所有平台上都是一样的\n\n![syncthing](https://pic.zhih.me/blog/posts/syncthing-the-best/syncthing.jpg)\n\n然后你需要做的就是\n\n### [](#设置用户名、密码 \"设置用户名、密码\")设置用户名、密码\n\n![setpass](https://pic.zhih.me/blog/posts/syncthing-the-best/setpass.jpg)\n\n### [](#设置文件夹 \"设置文件夹\")设置文件夹\n\n删除默认的同步文件夹，添加新同步文件夹\n\n![addlocal](https://pic.zhih.me/blog/posts/syncthing-the-best/addlocal.jpg)\n\n### [](#添加远程设备 \"添加远程设备\")添加远程设备\n\n![addremote](https://pic.zhih.me/blog/posts/syncthing-the-best/addremote.jpg)\n\n然后稍微等一分钟，两边就能连接上了\n\n最终效果\n\n![end](https://pic.zhih.me/blog/posts/syncthing-the-best/end.jpg)\n\n[](#结语 \"结语\")结语\n--------------\n\nSyncthing 作为一款跨平台同步软件，它简单易用、功能完善强大，具有很高的稳定性，很容易让人想出各种使用场景，而且它还是开源的，感谢那上百位贡献者\n\n本文简单介绍了初级使用方法，还未提及其他的诸如版本控制等功能，其他功能应用，如果以后我觉得值得一说，再更新了\n\n","tags":["syncthing","备份","软件"],"categories":["好软推荐"]},{"title":"MacOS上虚拟环境安装TensorFlow","url":"/TensorFlow/","content":"\n# MacOS上虚拟环境安装TensorFlow\n\n\n## 0x1 检查是否已经配置Python环境\n\n注意MacOS系统上只支持CPU的TensorFlow，而且对系统安装的Python版本有要求，仅支持以下Python版本。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124115513.png)\n\n\n```\npython3 --version\npip3 --version\nvirtualenv --version\n```\n\n如果已安装这些软件包，请跳至下一步。\n否则，请安装 Python、pip 软件包管理器和 Virtualenv：\n\n安装方式：\n首先安装Python3.6，可以去官网下载安装包或者通过homebrew安装\n下面介绍通过Homebrew安装方式\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nexport PATH=\"/usr/local/bin:/usr/local/sbin:$PATH\"\nbrew update\nbrew install python  # Python 3\nsudo pip3 install -U virtualenv  # system-wide install\n```\n\n## 0x2 创建虚拟环境\n**1、创建一个新的虚拟环境**，方法是选择 Python 解释器并创建一个 `./venv` 目录来存放它：\n```\nvirtualenv --system-site-packages -p python3 ./venv\n```\n如果这里出错了，提示`bash: virtualenv command not found`\n需要在编辑器中添加一个执行virtualenv的路径\n```\n    vim ~/.zshrc\n ```   \n编辑配置文件，加一行Python3.6的路径\n``` \n    export PATH=/Library/Frameworks/Python.framework/Versions/3.6/bin:$PATH\n```    \n:wq保存后记得激活下配置文件\n```\n    source ~/.zshrc    \n```    \n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124120831.png)\n\n**2、使用特定于 shell 的命令激活该虚拟环境：**\n创建好虚拟环境后，需要激活下环境\n```\n    source ./venv/bin/activate  # sh, bash, ksh, or zsh\n```   \n\n## 0x3 虚拟环境安装软件包\n\n当 virtualenv 处于有效状态时，shell 提示符带有 (venv) 前缀。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124121318.png)\n在不影响主机系统设置的情况下，在虚拟环境中安装软件包。首先升级 pip：\n```\n    pip install --upgrade pip\n    pip list  # 显示虚拟环境中安装的软件包\n```    \n之后要退出 virtualenv，请使用以下命令：\n```\n    deactivate  # 不要退出虚拟环境，直到你使用完TensorFlow\n```    \n    \n**安装 TensorFlow pip 软件包**\n```\n    pip install --upgrade tensorflow\n```\n验证安装效果\n```\n    python -c \"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))\"\n```","tags":["TensorFlow","Python","人工智能"],"categories":["Python"]},{"title":"Python科学计算：用NumPy快速处理数据","url":"/Numpy/","content":"# Python科学计算：用NumPy快速处理数据\n\n![](https://static001.geekbang.org/resource/image/28/50/284d3ab3a036a1617bb93bb09ef6d650.jpg)\n\nPython中一个非常重要的第三方库就是NumPy。\n\n它不仅是Python中使用最多的第三方库，而且还是SciPy、Pandas等数据科学的基础库。它所提供的数据结构比Python自身的“更高级、更高效”，可以这么说，NumPy所提供的数据结构是Python数据分析的基础。\n\n我上次讲到了Python数组结构中的列表list，它实际上相当于一个数组的结构。而NumPy中一个关键数据类型就是关于数组的，那为什么还存在这样一个第三方的数组结构呢？\n\n实际上，标准的Python中，用列表list保存数组的数值。由于列表中的元素可以是任意的对象，所以列表中list保存的是对象的指针。虽然在Python编程中隐去了指针的概念，但是数组有指针，Python的列表list其实就是数组。这样如果我要保存一个简单的数组\\[0,1,2\\]，就需要有3个指针和3个整数的对象，这样对于Python来说是非常不经济的，浪费了内存和计算时间。\n\n使用NumPy让你的Python科学计算更高效\n-----------------------\n\n为什么要用NumPy数组结构而不是Python本身的列表list？这是因为列表list的元素在系统内存中是分散存储的，而NumPy数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表list还需要对内存地址进行查找，从而节省了计算资源。\n\n另外在内存访问模式中，缓存会直接把字节块从RAM加载到CPU寄存器中。因为数据连续的存储在内存中，NumPy直接利用现代CPU的矢量化指令计算，加载寄存器中的多个连续浮点数。另外NumPy中的矩阵计算可以采用多线程的方式，充分利用多核CPU计算资源，大大提升了计算效率。\n\n当然除了使用NumPy外，你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是：**避免采用隐式拷贝，而是采用就地操作的方式**。举个例子，如果我想让一个数值x是原来的两倍，可以直接写成x*=2，而不要写成y=x*2。\n\n这样速度能快到2倍甚至更多。\n\n既然NumPy这么厉害，你该从哪儿入手学习呢？在NumPy里有两个重要的对象：ndarray（N-dimensional array object）解决了多维数组问题，而ufunc（universal function object）则是解决对数组进行处理的函数。下面，我就带你一一来看。\n\n**ndarray对象**\n\nndarray实际上是多维数组的含义。在NumPy数组中，维数称为秩（rank），一维数组的秩为1，二维数组的秩为2，以此类推。在NumPy中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。\n\n下面，你来看ndarray对象是如何创建数组的，又是如何处理结构数组的呢？\n\n**创建数组**\n\n    import numpy as np\n    a = np.array([1, 2, 3])\n    b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    b[1,1]=10\n    print a.shape\n    print b.shape\n    print a.dtype\n    print b\n    \n\n运行结果：\n\n    (3L,)\n    (3L, 3L)\n    int32\n    [[ 1  2  3]\n     [ 4 10  6]\n     [ 7  8  9]]\n    \n\n创建数组前，你需要引用NumPy库，可以直接通过array函数创建数组，如果是多重数组，比如示例里的b，那么该怎么做呢？你可以先把一个数组作为一个元素，然后嵌套起来，比如示例b中的\\[1,2,3\\]就是一个元素，然后\\[4,5,6\\]\\[7,8,9\\]也是作为元素，然后把三个元素再放到\\[\\]数组里，赋值给变量b。\n\n当然数组也是有属性的，比如你可以通过函数shape属性获得数组的大小，通过dtype获得元素的属性。如果你想对数组里的数值进行修改的话，直接赋值即可，注意下标是从0开始计的，所以如果你想对b数组，九宫格里的中间元素进行修改的话，下标应该是\\[1,1\\]。\n\n**结构数组**\n\n如果你想统计一个班级里面学生的姓名、年龄，以及语文、英语、数学成绩该怎么办？当然你可以用数组的下标来代表不同的字段，比如下标为0的是姓名、小标为1的是年龄等，但是这样不显性。\n\n实际上在C语言里，可以定义结构数组，也就是通过struct定义结构类型，结构中的字段占据连续的内存空间，每个结构体占用的内存大小都相同，那在NumPy中是怎样操作的呢？\n\n    import numpy as np\n    persontype = np.dtype({\n        'names':['name', 'age', 'chinese', 'math', 'english'],\n        'formats':['S32','i', 'i', 'i', 'f']})\n    peoples = np.array([(\"ZhangFei\",32,75,100, 90),(\"GuanYu\",24,85,96,88.5),\n           (\"ZhaoYun\",28,85,92,96.5),(\"HuangZhong\",29,65,85,100)],\n        dtype=persontype)\n    ages = peoples[:]['age']\n    chineses = peoples[:]['chinese']\n    maths = peoples[:]['math']\n    englishs = peoples[:]['english']\n    print np.mean(ages)\n    print np.mean(chineses)\n    print np.mean(maths)\n    print np.mean(englishs)\n    \n\n运行结果：\n\n    28.25\n    77.5\n    93.25\n    93.75\n    \n\n你看下这个例子，首先在NumPy中是用dtype定义的结构类型，然后在定义数组的时候，用array中指定了结构数组的类型dtype=persontype，这样你就可以自由地使用自定义的persontype了。比如想知道每个人的语文成绩，就可以用chineses = peoples\\[:\\]\\[‘chinese’\\]，当然NumPy中还有一些自带的数学运算，比如计算平均值使用np.mean。\n\n**ufunc运算**\n\nufunc是universal function的缩写，是不是听起来就感觉功能非常强大？确如其名，它能对数组中每个元素进行函数操作。NumPy中很多ufunc函数计算速度非常快，因为都是采用C语言实现的。\n\n**连续数组的创建**\n\nNumPy可以很方便地创建连续数组，比如我使用arange或linspace函数进行创建：\n\n    x1 = np.arange(1,11,2)\n    x2 = np.linspace(1,9,5)\n    \n\nnp.arange和np.linspace起到的作用是一样的，都是创建等差数组。这两个数组的结果x1,x2都是\\[1 3 5 7 9\\]。结果相同，但是你能看出来创建的方式是不同的。\n\narange()类似内置函数range()，通过指定**初始值、终值、步长**来创建等差数列的一维数组，默认是不包括终值的。\n\nlinspace是linear space的缩写，代表线性等分向量的含义。linspace()通过指定**初始值、终值、元素个数**来创建等差数列的一维数组，默认是包括终值的。\n\n**算数运算**\n\n通过NumPy可以自由地创建等差数组，同时也可以进行加、减、乘、除、求n次方和取余数。\n\n    x1 = np.arange(1,11,2)\n    x2 = np.linspace(1,9,5)\n    print np.add(x1, x2)\n    print np.subtract(x1, x2)\n    print np.multiply(x1, x2)\n    print np.divide(x1, x2)\n    print np.power(x1, x2)\n    print np.remainder(x1, x2)\n    \n\n运行结果：\n\n    [ 2.  6. 10. 14. 18.]\n    [0. 0. 0. 0. 0.]\n    [ 1.  9. 25. 49. 81.]\n    [1. 1. 1. 1. 1.]\n    [1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05\n     3.87420489e+08]\n    [0. 0. 0. 0. 0.]\n    \n\n我还以x1, x2数组为例，求这两个数组之间的加、减、乘、除、求n次方和取余数。在n次方中，x2数组中的元素实际上是次方的次数，x1数组的元素为基数。\n\n在取余函数里，你既可以用np.remainder(x1, x2)，也可以用np.mod(x1, x2)，结果是一样的。\n\n**统计函数**\n\n如果你想要对一堆数据有更清晰的认识，就需要对这些数据进行描述性的统计分析，比如了解这些数据中的最大值、最小值、平均值，是否符合正态分布，方差、标准差多少等等。它们可以让你更清楚地对这组数据有认知。\n\n下面我来介绍下在NumPy中如何使用这些统计函数。\n\n**计数组/矩阵中的最大值函数amax()，最小值函数amin()**\n\n    import numpy as np\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.amin(a)\n    print np.amin(a,0)\n    print np.amin(a,1)\n    print np.amax(a)\n    print np.amax(a,0)\n    print np.amax(a,1)\n    \n\n运行结果：\n\n    1\n    [1 2 3]\n    [1 4 7]\n    9\n    [7 8 9]\n    [3 6 9]\n    \n\namin() 用于计算数组中的元素沿指定轴的最小值。对于一个二维数组a，amin(a)指的是数组中全部元素的最小值，amin(a,0)是延着axis=0轴的最小值，axis=0轴是把元素看成了\\[1,2,3\\], \\[4,5,6\\], \\[7,8,9\\]三个元素，所以最小值为\\[1,2,3\\]，amin(a,1)是延着axis=1轴的最小值，axis=1轴是把元素看成了\\[1,4,7\\], \\[2,5,8\\], \\[3,6,9\\]三个元素，所以最小值为\\[1,4,7\\]。同理amax()是计算数组中元素沿指定轴的最大值。\n\n**统计最大值与最小值之差 ptp()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.ptp(a)\n    print np.ptp(a,0)\n    print np.ptp(a,1)\n    \n\n运行结果：\n\n    8\n    [6 6 6]\n    [2 2 2]\n    \n\n对于相同的数组a，np.ptp(a)可以统计数组中最大值与最小值的差，即9-1=8。同样ptp(a,0)统计的是沿着axis=0轴的最大值与最小值之差，即7-1=6（当然8-2=6,9-3=6，第三行减去第一行的ptp差均为6），ptp(a,1)统计的是沿着axis=1轴的最大值与最小值之差，即3-1=2（当然6-4=2, 9-7=2，即第三列与第一列的ptp差均为2）。\n\n**统计数组的百分位数 percentile()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.percentile(a, 50)\n    print np.percentile(a, 50, axis=0)\n    print np.percentile(a, 50, axis=1)\n    \n\n运行结果：\n\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    \n\n同样，percentile()代表着第 p 个百分位数，这里p的取值范围是0-100，如果p=0，那么就是求最小值，如果p=50就是求平均值，如果p=100就是求最大值。同样你也可以求得在axis=0 和 axis=1两个轴上的p%的百分位数。\n\n**统计数组中的中位数median()、平均数mean()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    #求中位数\n    print np.median(a)\n    print np.median(a, axis=0)\n    print np.median(a, axis=1)\n    #求平均数\n    print np.mean(a)\n    print np.mean(a, axis=0)\n    print np.mean(a, axis=1)\n    \n\n运行结果：\n\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    \n\n你可以用median()和mean()求数组的中位数、平均值，同样也可以求得在axis=0和1两个轴上的中位数、平均值。你可以自己练习下看看运行结果。\n\n**统计数组中的加权平均值average()**\n\n    a = np.array([1,2,3,4])\n    wts = np.array([1,2,3,4])\n    print np.average(a)\n    print np.average(a,weights=wts)\n    \n\n运行结果：\n\n    2.5\n    3.0\n    \n\naverage()函数可以求加权平均，加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的，所以np.average(a)=(1+2+3+4)/4=2.5，你也可以指定权重数组wts=\\[1,2,3,4\\]，这样加权平均np.average(a,weights=wts)=(1\\*1+2\\*2+3\\*3+4\\*4)/(1+2+3+4)=3.0。\n\n**统计数组中的标准差std()、方差var()**\n\n    a = np.array([1,2,3,4])\n    print np.std(a)\n    print np.var(a)\n    \n\n运行结果：\n\n    1.118033988749895\n    1.25\n    \n\n方差的计算是指每个数值与平均值之差的平方求和的平均值，即mean((x - x.mean())** 2)。标准差是方差的算术平方根。在数学意义上，代表的是一组数据离平均值的分散程度。所以np.var(a)=1.25, np.std(a)=1.118033988749895。\n\n**NumPy排序**\n\n排序是算法中使用频率最高的一种，也是在数据分析工作中常用的方法，计算机专业的同学会在大学期间的算法课中学习。\n\n那么这些排序算法在NumPy中实现起来其实非常简单，一条语句就可以搞定。这里你可以使用sort函数，sort(a, axis=-1, kind=‘quicksort’, order=None)，默认情况下使用的是快速排序；在kind里，可以指定quicksort、mergesort、heapsort分别表示快速排序、合并排序、堆排序。同样axis默认是-1，即沿着数组的最后一个轴进行排序，也可以取不同的axis轴，或者axis=None代表采用扁平化的方式作为一个向量进行排序。另外order字段，对于结构化的数组可以指定按照某个字段进行排序。\n\n    a = np.array([[4,3,2],[2,4,1]])\n    print np.sort(a)\n    print np.sort(a, axis=None)\n    print np.sort(a, axis=0)  \n    print np.sort(a, axis=1)  \n    \n\n运行结果：\n\n    [[2 3 4]\n     [1 2 4]]\n    [1 2 2 3 4 4]\n    [[2 3 1]\n     [4 4 2]]\n    [[2 3 4]\n     [1 2 4]]\n    \n\n你可以自己计算下这个运行结果，然后再跑一遍比对下。\n\n总结\n--\n\n在NumPy学习中，你重点要掌握的就是对数组的使用，因为这是NumPy和标准Python最大的区别。在NumPy中重新对数组进行了定义，同时提供了算术和统计运算，你也可以使用NumPy自带的排序功能，一句话就搞定各种排序算法。\n\n当然要理解NumPy提供的数据结构为什么比Python自身的“更高级、更高效”，要从对数据指针的引用角度进行理解。\n\n![](https://static001.geekbang.org/resource/image/7b/66/7ba74ca7776ac29a5dc94c272d72ff66.jpg)  \n","tags":["Python","NumPy","数据科学"],"categories":["Python"]}]