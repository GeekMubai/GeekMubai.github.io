[{"title":"Syncthing就是我要的同步备份软件","url":"/syncthing-the-best/","content":"\n[](#引言 \"引言\")引言\n--------------\n\n数据无价，平时不注意备份，电脑突然翻车就追悔莫及啦。\n\n最开始的时候，我在路由器上开启 Samba，每次编辑完项目就手动拷贝到路由器硬盘里，麻烦程度可想而知，后来又用了 Google Drive/One Drive，又因为它们的网络不理想，就又放弃使用了。\n\n其实就是很简单的需求，自动备份、速度快，然后去找了一下，发现一堆人推荐用 Rsync，这货我只在 VPS 上用过，拿来做镜像同步，但是要做实时同步，不好配置。\n\n我就想，这需求应该有一大堆人有吧，就去 github 搜索 sync，发现 Syncthing 这么个好东西，截止 2018-06-13 已经得到 20k+ 的 star，并且更新很活跃\n\n[](#介绍 \"介绍\")介绍\n--------------\n\n![logo](https://pic.zhih.me/blog/posts/syncthing-the-best/logo.jpg)\n\nSyncthing 是一个文件连续同步软件\n\n项目地址：[https://github.com/syncthing/syncthing](https://github.com/syncthing/syncthing)\n\n它有以下特性：\n\n*   跨平台\n    \n    *   使用 Golang 开发，几乎能在所有平台上使用，包括常见的安卓手机和路由器平台\n*   易于使用\n    \n    *   只需要下载运行，打开浏览设置本地目录和远程主机，其他的不需要管\n*   安全\n    \n    *   管理页可以设置密码，可以设置 https，设置备份需要两边都确认，使用唯一设备标识进行确认\n\n[](#安装 \"安装\")安装\n--------------\n\nSyncthing 有多种安装方式\n\n有一定 Linux 基础的人，可以使用下面的配置来设置启动服务\n\n*   [https://github.com/syncthing/syncthing/tree/master/etc](https://github.com/syncthing/syncthing/tree/master/etc)\n\nWindows，Mac，Linux 和安卓手机可以在这里下载有 GUI 界面的程序使用\n\n*   [https://docs.syncthing.net/users/contrib.html#gui-wrappers](https://docs.syncthing.net/users/contrib.html#gui-wrappers)\n\n其他方法可以自己决定，我是直接下载安装包命令行启动的\n\n### [](#在-MacOS-上安装 \"在 MacOS 上安装\")在 MacOS 上安装\n\n我用的是 MacOS，可以直接使用 homebrew 安装启动，并且可以开机自动启动，你也可以到这里 [QSyncthingTray](https://github.com/sieren/QSyncthingTray/releases) 下载 MacOS 的 GUI 版\n\n```\nbrew install syncthing  \n```\n\n启动服务（同时设置开机启动）\n\n```\nbrew services start syncthing  \n```\n\n停止服务（同时关闭自启）\n\n```\nbrew services stop syncthing  \n```\n\n手动启动（不会开机自启）\n\n```\nsyncthing  \n```\n\n启动进程后，可以用浏览器打开 `http://localhost:8384/` 来查看 web 管理页\n\n### [](#在-Windows-上安装 \"在 Windows 上安装\")在 Windows 上安装\n\nWindows 直接在这里 [SyncTrayzor](https://github.com/canton7/SyncTrayzor/releases) 下载软件运行\n\n### [](#在-Linux-VPS-上安装 \"在 Linux VPS 上安装\")在 Linux VPS 上安装\n\n大多数发行版和不同 CPU 平台的安装包，可以在这里 [Syncthing](https://github.com/syncthing/syncthing/releases) 找到，把它下载到你想要放在的目录然后设置权限，使用命令运行\n\n文章开头有 GUI 版本的链接，不过我要装在没有 GUI 的 VPS 上，所以直接用命令行运行，系统用的是 Debian 9，然后用 supervisor 进程守护来启动的\n\n碰巧前几天之前的一个客户，他的 VPS 做迁移，阿里云送了张代金券，然后客户就送给我了\n\n![aff](https://pic.zhih.me/blog/posts/syncthing-the-best/aff.jpg)\n\n然后续费 9 个月的阿里云学生机，美滋滋😎\n\n虽然带宽比较低，但是对于这种连续同步的备份来说，在第一次备份之后，后面都是增量备份了，除非你都是备份大文件，要不对带宽的要求不是很高，另外 40G 的盘，完全够我备份用了，阿里云最主要就是稳定，很适合做我的备份机\n\n#### [](#下载-Syncthing \"下载 Syncthing\")下载 Syncthing\n\n下载最新的包，解压，移动到 `/bin/` 里，改权限\n\n```\nwget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \ntar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \nmv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /bin/  \n  \nchmod +x /bin/syncthing  \n```\n\n#### [](#进程守护 \"进程守护\")进程守护\n\n安装 supervisor\n\n```\napt-get install supervisor  \n```\n\n配置守护\n\n```\nvi /etc/supervisor/conf.d/syncthing.conf  \n```\n\n填入以下内容\n\n```\n\\[program:syncthing\\]  \ncommand = /bin/syncthing -no-browser -home=\"/root/.config/syncthing\"  \ndirectory = /root  \nautorestart = True  \nuser = root  \nenvironment = STNORESTART=\"1\", HOME=\"/root\"  \n```\n\n**注意**，我例子里使用的是 root 用户，所以响应的目录是 `/root`，你要是使用其他用户，应该是 `/home/用户名`，就是你登录时默认所在的目录\n\n现在就可以使用 `supervisorctl` 命令来管理进程了\n\n*   启动\n\n```\nsupervisorctl start syncthing  \n```\n\n*   重启\n```\nsupervisorctl restart syncthing  \n```\n*   停止\n```\nsupervisorctl stop syncthing  \n```\n启动进程后，可以用浏览器打开 `http://你的IP:8384/` 来查看 web 管理页\n\n如果无法打开页面，需要修改 `/.config/syncthing/config.xml` 里的 `127.0.0.1:8384` 字段为 `0.0.0.0:8384`，或者你可以和我一样使用 nginx 做反向代理，前提是你知道怎么做\n\n### [](#在路由器上安装 \"在路由器上安装\")在路由器上安装\n\n目前 [Entware](https://entware.net/) 源里已经有这个包了，但是我发现它是个旧版本，并且有问题，所以这里我选择手动安装\n\n这里的例子是 LEDE x64 但是也适合一切安装了 Entware 的路由器\n\n在这里 [Syncthing](https://github.com/syncthing/syncthing/releases) 下载对应 CPU 平台的安装包，可以用 `uname -m` 查看，我这里是 x86_64 所以选择 amd64\n\n#### [](#下载-syncthing \"下载 syncthing\")下载 syncthing\n\n下载最新的包，解压，移动到 `/opt/bin/` 里，改权限\n```\nwget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \ntar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \nmv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /opt/bin/  \n  \nchmod +x /opt/bin/syncthing  \n```\n#### [](#添加启动命令 \"添加启动命令\")添加启动命令\n\n创建并编辑 `/opt/etc/init.d/S92syncthing`\n```\nvi /opt/etc/init.d/S92syncthing  \n```\n在里面填上下面所有字段\n\n```\n #!/bin/sh  \nENABLED=yes  \nPROCS=syncthing  \nARGS=\"-home=/opt/etc/syncthing\"  \nPREARGS=\"\"  \nDESC=$PROCS  \nPATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin  \n  \nif \\[ ! -d /opt/etc/syncthing \\]; then  \n /opt/bin/syncthing -generate=\"/opt/etc/syncthing\"  \n sed -i 's|127.0.0.1:8384|0.0.0.0:8384|' /opt/etc/syncthing/config.xml  \nelif \\[\\[ -f /opt/etc/syncthing/config.xml -a \"127.0.0.1:8384\"==\"127.0.0.1:8384\" \\]\\]; then  \n sed -i 's|127.0.0.1:8384|0.0.0.0:8384|' /opt/etc/syncthing/config.xml  \nfi  \n  \n. /opt/etc/init.d/rc.func  \n```\n然后给权限\n```\nchmod +x /opt/etc/init.d/S92syncthing  \n```\n用法: /opt/etc/init.d/S92syncthing (start|stop|restart|check)\n\n启动服务就能在浏览器打开 `路由器IP:8384` 例如 `192.168.1.1:8384` 打开管理页了\n\n[](#使用方法 \"使用方法\")使用方法\n--------------------\n\n易于使用是 Syncthing 的一个重要特性，打开管理页，一目了然\n\n首次打开管理页，所有平台上都是一样的\n\n![syncthing](https://pic.zhih.me/blog/posts/syncthing-the-best/syncthing.jpg)\n\n然后你需要做的就是\n\n### [](#设置用户名、密码 \"设置用户名、密码\")设置用户名、密码\n\n![setpass](https://pic.zhih.me/blog/posts/syncthing-the-best/setpass.jpg)\n\n### [](#设置文件夹 \"设置文件夹\")设置文件夹\n\n删除默认的同步文件夹，添加新同步文件夹\n\n![addlocal](https://pic.zhih.me/blog/posts/syncthing-the-best/addlocal.jpg)\n\n### [](#添加远程设备 \"添加远程设备\")添加远程设备\n\n![addremote](https://pic.zhih.me/blog/posts/syncthing-the-best/addremote.jpg)\n\n然后稍微等一分钟，两边就能连接上了\n\n最终效果\n\n![end](https://pic.zhih.me/blog/posts/syncthing-the-best/end.jpg)\n\n[](#结语 \"结语\")结语\n--------------\n\nSyncthing 作为一款跨平台同步软件，它简单易用、功能完善强大，具有很高的稳定性，很容易让人想出各种使用场景，而且它还是开源的，感谢那上百位贡献者\n\n本文简单介绍了初级使用方法，还未提及其他的诸如版本控制等功能，其他功能应用，如果以后我觉得值得一说，再更新了\n\n","tags":["syncthing","备份","软件"],"categories":["好软推荐"]},{"title":"MacDMG","url":"/MacDMG/"},{"title":"MacOS上虚拟环境安装TensorFlow","url":"/TensorFlow/","content":"\n# MacOS上虚拟环境安装TensorFlow\n\n\n## 0x1 检查是否已经配置Python环境\n\n注意MacOS系统上只支持CPU的TensorFlow，而且对系统安装的Python版本有要求，仅支持以下Python版本。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124115513.png)\n\n\n```\npython3 --version\npip3 --version\nvirtualenv --version\n```\n\n如果已安装这些软件包，请跳至下一步。\n否则，请安装 Python、pip 软件包管理器和 Virtualenv：\n\n安装方式：\n首先安装Python3.6，可以去官网下载安装包或者通过homebrew安装\n下面介绍通过Homebrew安装方式\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nexport PATH=\"/usr/local/bin:/usr/local/sbin:$PATH\"\nbrew update\nbrew install python  # Python 3\nsudo pip3 install -U virtualenv  # system-wide install\n```\n\n## 0x2 创建虚拟环境\n**1、创建一个新的虚拟环境**，方法是选择 Python 解释器并创建一个 `./venv` 目录来存放它：\n```\nvirtualenv --system-site-packages -p python3 ./venv\n```\n如果这里出错了，提示`bash: virtualenv command not found`\n需要在编辑器中添加一个执行virtualenv的路径\n```\n    vim ~/.zshrc\n ```   \n编辑配置文件，加一行Python3.6的路径\n``` \n    export PATH=/Library/Frameworks/Python.framework/Versions/3.6/bin:$PATH\n```    \n:wq保存后记得激活下配置文件\n```\n    source ~/.zshrc    \n```    \n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124120831.png)\n\n**2、使用特定于 shell 的命令激活该虚拟环境：**\n创建好虚拟环境后，需要激活下环境\n```\n    source ./venv/bin/activate  # sh, bash, ksh, or zsh\n```   \n\n## 0x3 虚拟环境安装软件包\n\n当 virtualenv 处于有效状态时，shell 提示符带有 (venv) 前缀。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124121318.png)\n在不影响主机系统设置的情况下，在虚拟环境中安装软件包。首先升级 pip：\n```\n    pip install --upgrade pip\n    pip list  # 显示虚拟环境中安装的软件包\n```    \n之后要退出 virtualenv，请使用以下命令：\n```\n    deactivate  # 不要退出虚拟环境，直到你使用完TensorFlow\n```    \n    \n**安装 TensorFlow pip 软件包**\n```\n    pip install --upgrade tensorflow\n```\n验证安装效果\n```\n    python -c \"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))\"\n```","tags":["TensorFlow","Python","人工智能"],"categories":["Python"]},{"title":"Python科学计算：用NumPy快速处理数据","url":"/Numpy/","content":"# Python科学计算：用NumPy快速处理数据\n\n![](https://static001.geekbang.org/resource/image/28/50/284d3ab3a036a1617bb93bb09ef6d650.jpg)\n\nPython中一个非常重要的第三方库就是NumPy。\n\n它不仅是Python中使用最多的第三方库，而且还是SciPy、Pandas等数据科学的基础库。它所提供的数据结构比Python自身的“更高级、更高效”，可以这么说，NumPy所提供的数据结构是Python数据分析的基础。\n\n我上次讲到了Python数组结构中的列表list，它实际上相当于一个数组的结构。而NumPy中一个关键数据类型就是关于数组的，那为什么还存在这样一个第三方的数组结构呢？\n\n实际上，标准的Python中，用列表list保存数组的数值。由于列表中的元素可以是任意的对象，所以列表中list保存的是对象的指针。虽然在Python编程中隐去了指针的概念，但是数组有指针，Python的列表list其实就是数组。这样如果我要保存一个简单的数组\\[0,1,2\\]，就需要有3个指针和3个整数的对象，这样对于Python来说是非常不经济的，浪费了内存和计算时间。\n\n使用NumPy让你的Python科学计算更高效\n-----------------------\n\n为什么要用NumPy数组结构而不是Python本身的列表list？这是因为列表list的元素在系统内存中是分散存储的，而NumPy数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表list还需要对内存地址进行查找，从而节省了计算资源。\n\n另外在内存访问模式中，缓存会直接把字节块从RAM加载到CPU寄存器中。因为数据连续的存储在内存中，NumPy直接利用现代CPU的矢量化指令计算，加载寄存器中的多个连续浮点数。另外NumPy中的矩阵计算可以采用多线程的方式，充分利用多核CPU计算资源，大大提升了计算效率。\n\n当然除了使用NumPy外，你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是：**避免采用隐式拷贝，而是采用就地操作的方式**。举个例子，如果我想让一个数值x是原来的两倍，可以直接写成x*=2，而不要写成y=x*2。\n\n这样速度能快到2倍甚至更多。\n\n既然NumPy这么厉害，你该从哪儿入手学习呢？在NumPy里有两个重要的对象：ndarray（N-dimensional array object）解决了多维数组问题，而ufunc（universal function object）则是解决对数组进行处理的函数。下面，我就带你一一来看。\n\n**ndarray对象**\n\nndarray实际上是多维数组的含义。在NumPy数组中，维数称为秩（rank），一维数组的秩为1，二维数组的秩为2，以此类推。在NumPy中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。\n\n下面，你来看ndarray对象是如何创建数组的，又是如何处理结构数组的呢？\n\n**创建数组**\n\n    import numpy as np\n    a = np.array([1, 2, 3])\n    b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    b[1,1]=10\n    print a.shape\n    print b.shape\n    print a.dtype\n    print b\n    \n\n运行结果：\n\n    (3L,)\n    (3L, 3L)\n    int32\n    [[ 1  2  3]\n     [ 4 10  6]\n     [ 7  8  9]]\n    \n\n创建数组前，你需要引用NumPy库，可以直接通过array函数创建数组，如果是多重数组，比如示例里的b，那么该怎么做呢？你可以先把一个数组作为一个元素，然后嵌套起来，比如示例b中的\\[1,2,3\\]就是一个元素，然后\\[4,5,6\\]\\[7,8,9\\]也是作为元素，然后把三个元素再放到\\[\\]数组里，赋值给变量b。\n\n当然数组也是有属性的，比如你可以通过函数shape属性获得数组的大小，通过dtype获得元素的属性。如果你想对数组里的数值进行修改的话，直接赋值即可，注意下标是从0开始计的，所以如果你想对b数组，九宫格里的中间元素进行修改的话，下标应该是\\[1,1\\]。\n\n**结构数组**\n\n如果你想统计一个班级里面学生的姓名、年龄，以及语文、英语、数学成绩该怎么办？当然你可以用数组的下标来代表不同的字段，比如下标为0的是姓名、小标为1的是年龄等，但是这样不显性。\n\n实际上在C语言里，可以定义结构数组，也就是通过struct定义结构类型，结构中的字段占据连续的内存空间，每个结构体占用的内存大小都相同，那在NumPy中是怎样操作的呢？\n\n    import numpy as np\n    persontype = np.dtype({\n        'names':['name', 'age', 'chinese', 'math', 'english'],\n        'formats':['S32','i', 'i', 'i', 'f']})\n    peoples = np.array([(\"ZhangFei\",32,75,100, 90),(\"GuanYu\",24,85,96,88.5),\n           (\"ZhaoYun\",28,85,92,96.5),(\"HuangZhong\",29,65,85,100)],\n        dtype=persontype)\n    ages = peoples[:]['age']\n    chineses = peoples[:]['chinese']\n    maths = peoples[:]['math']\n    englishs = peoples[:]['english']\n    print np.mean(ages)\n    print np.mean(chineses)\n    print np.mean(maths)\n    print np.mean(englishs)\n    \n\n运行结果：\n\n    28.25\n    77.5\n    93.25\n    93.75\n    \n\n你看下这个例子，首先在NumPy中是用dtype定义的结构类型，然后在定义数组的时候，用array中指定了结构数组的类型dtype=persontype，这样你就可以自由地使用自定义的persontype了。比如想知道每个人的语文成绩，就可以用chineses = peoples\\[:\\]\\[‘chinese’\\]，当然NumPy中还有一些自带的数学运算，比如计算平均值使用np.mean。\n\n**ufunc运算**\n\nufunc是universal function的缩写，是不是听起来就感觉功能非常强大？确如其名，它能对数组中每个元素进行函数操作。NumPy中很多ufunc函数计算速度非常快，因为都是采用C语言实现的。\n\n**连续数组的创建**\n\nNumPy可以很方便地创建连续数组，比如我使用arange或linspace函数进行创建：\n\n    x1 = np.arange(1,11,2)\n    x2 = np.linspace(1,9,5)\n    \n\nnp.arange和np.linspace起到的作用是一样的，都是创建等差数组。这两个数组的结果x1,x2都是\\[1 3 5 7 9\\]。结果相同，但是你能看出来创建的方式是不同的。\n\narange()类似内置函数range()，通过指定**初始值、终值、步长**来创建等差数列的一维数组，默认是不包括终值的。\n\nlinspace是linear space的缩写，代表线性等分向量的含义。linspace()通过指定**初始值、终值、元素个数**来创建等差数列的一维数组，默认是包括终值的。\n\n**算数运算**\n\n通过NumPy可以自由地创建等差数组，同时也可以进行加、减、乘、除、求n次方和取余数。\n\n    x1 = np.arange(1,11,2)\n    x2 = np.linspace(1,9,5)\n    print np.add(x1, x2)\n    print np.subtract(x1, x2)\n    print np.multiply(x1, x2)\n    print np.divide(x1, x2)\n    print np.power(x1, x2)\n    print np.remainder(x1, x2)\n    \n\n运行结果：\n\n    [ 2.  6. 10. 14. 18.]\n    [0. 0. 0. 0. 0.]\n    [ 1.  9. 25. 49. 81.]\n    [1. 1. 1. 1. 1.]\n    [1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05\n     3.87420489e+08]\n    [0. 0. 0. 0. 0.]\n    \n\n我还以x1, x2数组为例，求这两个数组之间的加、减、乘、除、求n次方和取余数。在n次方中，x2数组中的元素实际上是次方的次数，x1数组的元素为基数。\n\n在取余函数里，你既可以用np.remainder(x1, x2)，也可以用np.mod(x1, x2)，结果是一样的。\n\n**统计函数**\n\n如果你想要对一堆数据有更清晰的认识，就需要对这些数据进行描述性的统计分析，比如了解这些数据中的最大值、最小值、平均值，是否符合正态分布，方差、标准差多少等等。它们可以让你更清楚地对这组数据有认知。\n\n下面我来介绍下在NumPy中如何使用这些统计函数。\n\n**计数组/矩阵中的最大值函数amax()，最小值函数amin()**\n\n    import numpy as np\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.amin(a)\n    print np.amin(a,0)\n    print np.amin(a,1)\n    print np.amax(a)\n    print np.amax(a,0)\n    print np.amax(a,1)\n    \n\n运行结果：\n\n    1\n    [1 2 3]\n    [1 4 7]\n    9\n    [7 8 9]\n    [3 6 9]\n    \n\namin() 用于计算数组中的元素沿指定轴的最小值。对于一个二维数组a，amin(a)指的是数组中全部元素的最小值，amin(a,0)是延着axis=0轴的最小值，axis=0轴是把元素看成了\\[1,2,3\\], \\[4,5,6\\], \\[7,8,9\\]三个元素，所以最小值为\\[1,2,3\\]，amin(a,1)是延着axis=1轴的最小值，axis=1轴是把元素看成了\\[1,4,7\\], \\[2,5,8\\], \\[3,6,9\\]三个元素，所以最小值为\\[1,4,7\\]。同理amax()是计算数组中元素沿指定轴的最大值。\n\n**统计最大值与最小值之差 ptp()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.ptp(a)\n    print np.ptp(a,0)\n    print np.ptp(a,1)\n    \n\n运行结果：\n\n    8\n    [6 6 6]\n    [2 2 2]\n    \n\n对于相同的数组a，np.ptp(a)可以统计数组中最大值与最小值的差，即9-1=8。同样ptp(a,0)统计的是沿着axis=0轴的最大值与最小值之差，即7-1=6（当然8-2=6,9-3=6，第三行减去第一行的ptp差均为6），ptp(a,1)统计的是沿着axis=1轴的最大值与最小值之差，即3-1=2（当然6-4=2, 9-7=2，即第三列与第一列的ptp差均为2）。\n\n**统计数组的百分位数 percentile()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.percentile(a, 50)\n    print np.percentile(a, 50, axis=0)\n    print np.percentile(a, 50, axis=1)\n    \n\n运行结果：\n\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    \n\n同样，percentile()代表着第 p 个百分位数，这里p的取值范围是0-100，如果p=0，那么就是求最小值，如果p=50就是求平均值，如果p=100就是求最大值。同样你也可以求得在axis=0 和 axis=1两个轴上的p%的百分位数。\n\n**统计数组中的中位数median()、平均数mean()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    #求中位数\n    print np.median(a)\n    print np.median(a, axis=0)\n    print np.median(a, axis=1)\n    #求平均数\n    print np.mean(a)\n    print np.mean(a, axis=0)\n    print np.mean(a, axis=1)\n    \n\n运行结果：\n\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    \n\n你可以用median()和mean()求数组的中位数、平均值，同样也可以求得在axis=0和1两个轴上的中位数、平均值。你可以自己练习下看看运行结果。\n\n**统计数组中的加权平均值average()**\n\n    a = np.array([1,2,3,4])\n    wts = np.array([1,2,3,4])\n    print np.average(a)\n    print np.average(a,weights=wts)\n    \n\n运行结果：\n\n    2.5\n    3.0\n    \n\naverage()函数可以求加权平均，加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的，所以np.average(a)=(1+2+3+4)/4=2.5，你也可以指定权重数组wts=\\[1,2,3,4\\]，这样加权平均np.average(a,weights=wts)=(1\\*1+2\\*2+3\\*3+4\\*4)/(1+2+3+4)=3.0。\n\n**统计数组中的标准差std()、方差var()**\n\n    a = np.array([1,2,3,4])\n    print np.std(a)\n    print np.var(a)\n    \n\n运行结果：\n\n    1.118033988749895\n    1.25\n    \n\n方差的计算是指每个数值与平均值之差的平方求和的平均值，即mean((x - x.mean())** 2)。标准差是方差的算术平方根。在数学意义上，代表的是一组数据离平均值的分散程度。所以np.var(a)=1.25, np.std(a)=1.118033988749895。\n\n**NumPy排序**\n\n排序是算法中使用频率最高的一种，也是在数据分析工作中常用的方法，计算机专业的同学会在大学期间的算法课中学习。\n\n那么这些排序算法在NumPy中实现起来其实非常简单，一条语句就可以搞定。这里你可以使用sort函数，sort(a, axis=-1, kind=‘quicksort’, order=None)，默认情况下使用的是快速排序；在kind里，可以指定quicksort、mergesort、heapsort分别表示快速排序、合并排序、堆排序。同样axis默认是-1，即沿着数组的最后一个轴进行排序，也可以取不同的axis轴，或者axis=None代表采用扁平化的方式作为一个向量进行排序。另外order字段，对于结构化的数组可以指定按照某个字段进行排序。\n\n    a = np.array([[4,3,2],[2,4,1]])\n    print np.sort(a)\n    print np.sort(a, axis=None)\n    print np.sort(a, axis=0)  \n    print np.sort(a, axis=1)  \n    \n\n运行结果：\n\n    [[2 3 4]\n     [1 2 4]]\n    [1 2 2 3 4 4]\n    [[2 3 1]\n     [4 4 2]]\n    [[2 3 4]\n     [1 2 4]]\n    \n\n你可以自己计算下这个运行结果，然后再跑一遍比对下。\n\n总结\n--\n\n在NumPy学习中，你重点要掌握的就是对数组的使用，因为这是NumPy和标准Python最大的区别。在NumPy中重新对数组进行了定义，同时提供了算术和统计运算，你也可以使用NumPy自带的排序功能，一句话就搞定各种排序算法。\n\n当然要理解NumPy提供的数据结构为什么比Python自身的“更高级、更高效”，要从对数据指针的引用角度进行理解。\n\n![](https://static001.geekbang.org/resource/image/7b/66/7ba74ca7776ac29a5dc94c272d72ff66.jpg)  \n","tags":["Python","NumPy","数据科学"],"categories":["Python"]}]