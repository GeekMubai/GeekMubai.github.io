[{"title":"在 Windows 上享受更棒的字体渲染","url":"/better-font-on-win/","content":"\nWindows 的字体渲染问题一直是一个老大难，每隔一段时间就会有人吐槽 Windows 的字体有多难看、macOS 的字体又有多美观。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203203949.png)\n\n实际上，微软在这方面并非毫无作为，而是进行过多次优化。但由于软硬件上的种种限制，让广大群众至今没能真正享受到高质量的字体渲染效果。\n今天就让我来带大家仔细讲讲 Windows 的字体渲染为什么这么差，以及如何用稳定的方法解决字体渲染问题。\n\n## Windows 的字体渲染问题出在哪里？\n长期使用 macOS 的用户可能无法理解 Windows 用户到底在发什么牢骚。\n为了有一个直观的感受，我在 Windows 和 macOS 中各截取了一些文字。对比一下下面这两段文字，就会发现它们的实际观感区别很大。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204101.png)\n> macOS 下的字体\n\n将 macOS 下的文字放大后观察，字体美观、边缘厚实，一笔一划很是清晰。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204244.png)\n\n>Windows 10 下的字体\n\nWindows 的字体只能算是能够看清，但边缘总有些发虚，对比之后则略逊一筹。放大后观察，边缘有一些红绿小色块，「安」字中间的一横显得颜色很深，整体多少有些不协调。\n而出现这种情况的原因有很多，我总结了以下 3 点——\n\n### 屏幕显示分辨率低\n屏幕的显示分辨率是首当其冲的问题。\n为了描述这个问题是怎么出现的，除了屏幕本身的分辨率和尺寸之外，我们还需要了解显示器的一个重要参数：PPI（Pixels Per Inch），指的是「每英寸的像素数量」。\n我们可以用一个公式来计算出屏幕的 PPI：√(纵向像素数² + 横向像素数²) / 屏幕尺寸\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204350.png)\n\n比如一块 1920 x 1080 的 15.6 寸显示器，它的 PPI 就是 √(1920² + 1080²) / 15.6 = 141.21。从这个公式中可以看出「同等分辨率的屏幕越大，PPI 就越低」。\n如果我们想在屏幕上显示文字，就需要在像素点阵中填充内容。比如你想在 12 x 12 的点阵下塞进一个中文汉字，只用黑白两色填充就只能得到图中的点阵文字。只有换成一个更大的点阵，笔画之间才会有空间填充更多的笔画细节，从而使笔画之间变得更为顺滑。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204432.png)\n\n近些年出产的 Mac 都配备上了 Retina 屏幕，分辨率从 2560 x 1600 到最高的 5120 x 2880 不等，PPI 可以达到 227。实际使用时，macOS 通常会采用缩放，让一块高分辨率的屏幕显示更多的内容，文字自然会变得更加清晰。\n而 Windows 方面，仍然有大量的电脑在使用 1920 x 1080 的分辨率和更低分辨率的显示器，大多数万元以下的笔记本配备的也是 1080P 甚至是 1366 x 768 的显示器。一块 15.6 寸的 1080P 屏幕，PPI 只能达到 141 上下。相比高 PPI 的 Mac，Windows 的文字显示自然比不过它。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204449.png)\n\n所以，屏幕分辨率属于 Mac 天然的硬件优势。\n\n### 字体问题\n\n第二个问题在于字体。 字体的字形不同，也会影响字体的显示效果。\n比如在 Word 中使用四号宋体，边缘会显得模糊，而小四、五号等字号时，边缘则十分锐利。即使直接在 Word 中使用苹方字体，边缘也会出现一定的模糊。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204521.png)\n\n这种进行模糊处理的方式，其实是 **Windows 对于低分辨率屏幕下字体显示进行的特殊处理：Hint**。每个字体本身会带有一个 GASP 表，Windows 的渲染引擎会根据这些 GASP 表来判断是否需要做处理。\n当屏幕分辨率过低或是字太小，不足以显示所有文字细节时，Windows 就会启动 Hint 让文字变得更清晰，这本来是一件好事。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204553.png)\n\n然而如果字体的 GASP 表不完善，就会让 Hint 误操作，本来就是可以正常显示字体的高分屏，但经过 Hint 处理过后，原本清晰的字体反而变得模糊、笔画高低不平了，这就是字体本身的问题。\n这个问题曾出现在 Windows 的默认字体微软雅黑上。如今最新版的 Windows 10 中内置的微软雅黑已经进行过优化，比以前要好很多了。\n\n### 渲染方式问题\n\n如果排除上面两个因素，最后的问题就是系统的文字渲染方式了。\n粗略地讲，Windows 目前采用三种不同的渲染方式，它们之间是相互补充的关系，同时存在于系统中。\n* GDI+（Graphical Device Interface）：GDI 渲染指的是图形设备接口，属于 Windows 的核心组件之一。GDI 的历史很悠久，许多年迈的 Win32 软件都采用 GDI 来渲染字体。GDI+ 是它的改进版。\n* ClearType：为了提升 LCD 屏幕的字体渲染效果而推出的改进功能，也是目前 Win 10 主要采用的字体渲染方式。准确地讲这并不是渲染引擎，称为字符平滑工具、抗锯齿功能更为合适。\n* DirectWrite：为了提升高分辨率屏幕的字体渲染做的优化引擎。需要开发者做支持，全面进入 DirectWrite 时代还需经历时日。目前主要是 UWP 应用在使用。\n其中的传统字体渲染引擎 GDI 很老，采用 GDI 的 Win32 软件在高分辨率屏幕下使用 100% 之外的缩放就会出现模糊。但由于采用 GDI 的软件实在太多，牵一发而动全身，微软无法轻易换掉 GDI。\n于是 ClearType 便应运而生。ClearType 的原理是让显示器的 R , G , B 次像素放光，在 x 和 y 轴上增加一些颜色进行微调，使得文字更清晰。\n\n不过这尚未真正解决问题，在 Windows 10 默认启用 ClearType 的情况下，文字表现依然不佳。最前面的对比图中，Windows 的文字边缘就有这种红绿小色块的身影。在低分屏下，这种小色块会让文字边缘显得「有些糊」，中文的笔画也会有深有浅。\n\n**于是微软又推出了新的 DirectWrite 引擎，它就是为了取代 GDI 和 GDI+ 而诞生的。**它的渲染方式已经和 iOS、Android 上采用的 FreeType 引擎效果接近，只是我们日常用的许多老软件未做适配。所以这也是为什么 UWP 应用的字体渲染会比 Win32 软件看起来要好一些的原因。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204703.png)\n\n如果做一个形象的比喻，那么 GDI 就是年迈的老人，ClearType 就是一副眼镜，DirectWrite 则是更能干的接班人。\n可以发现，字体渲染方式的问题其实是多方面的，根源就在于 GDI 的老旧、ClearType 的不完善、软件不跟进 DirectWrite 这些问题上。这几个渲染方式会影响到优化时的一些操作，我们后面还会提到。\n\n## 如何搞定渲染\n\n了解字体渲染效果差的原因之后，我们可以发现 Windows 的字体渲染问题还不少，这些问题可以有很多种解决方法，括号中是解法的简单概括——\n* 显示器分辨率过低（更换硬件）\n* 老软件适配差（Win32 应用、单独调整）\n* 字体本身产生模糊（更换字体、修改字体本身）\n* 字体丑，想换字体（更换字体）\n* 渲染时产生的模糊（更换渲染引擎）\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204733.png)\n\n明确了问题和产生问题的原因，那我们就根据这几个问题来分别做出对应的优化。\n下面我从简单到复杂，介绍多种优化字体渲染的方法。由于没有人会愿意因为美观而舍弃系统的稳定性，所以在下列方法中，不会出现改动注册表、手动修改系统文件的方法，稳定性 永远是第一要素。\n\n### 解决显示器分辨率过低、老软件适配差问题\n\n其中显示器分辨率属于硬件问题，想一劳永逸地解决问题，可以选择购置 2K 分辨率以上的显示器，Windows 在高分屏上的字体渲染表现不俗。然而，考虑到 2K 显示器「同样不俗」的价格，大部分人还是会选择在现有的硬件资源上进行软件优化。\n如果想在现有的硬件上做优化，最简单最安全的方法自然是 Windows 内置的方案了。\n\n#### 直接修改缩放\n在 Windows 中提供了一个简单的「缩放功能」来放大系统的界面。它的效果是让一个文字获得更多的像素点。从而获得更好的视觉体验。\n在「设置 - 系统 - 显示 - 缩放与布局」中调整「更改文本、应用等项目的大小」，从 100% 到 200% 不等。这些选项中 Windows 会给出一个推荐选项，可以选择适当提升一档。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204830.png)\n\n如果你觉得 200% 的缩放仍然不够，「高级缩放设置」中允许你调整到 100% - 500% 之间的任意数字。不过一般不建议改动这一项。\n\n#### 修改单个应用的缩放\n不过调整缩放之后，会让一些对 DPI 缩放支持较差的老应用出现严重模糊，像是老版本的迅雷、QQ 等软件。这时候可以单独调整应用的缩放。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204859.png)\n\n在软件的快捷方式上右键，打开属性菜单。如果是在任务栏上的软件，「右键图标 - 右键菜单中的名称 - 属性」就可以进入属性设置界面。\n然后在「兼容性」选项卡中，选择「更改高 DPI 设置」，选中「替代高 DPI 的缩放行为」。其中的 应用程序 指的是让软件保持 100% ，系统 指的是根据系统设置的缩放比例来调整（可能会变得模糊），系统（增强） 会对那些基于 GDI 渲染方式的软件进行更多的优化。\n所以如果遇到了上面的问题，你可以选择使用 应用程序 或是 系统（增强） 来做一些特殊调整。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204930.png)\n\n#### 修改字体大小\n如果你目前正在使用的就是高分辨率的屏幕，反而觉得有些字太小、看不清。又不想调整所有界面的缩放，那就可以根据需要单独调整文字的大小。\n在「设置 - 轻松使用 - 显示 - 放大文本」中调整滑块，然后选择「应用」。\n之后电脑会进入半分钟左右的等待时间，结束后，Windows 中的所有文字都会被放大一些，文字的观感也会有所提升。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203204959.png)\n\n这三种方法都是 Windows 内置的方法，经过简单且安全的操作，就可以让我们在分辨率稍低的显示器上获得较好的文字观感。同时解决了一部分老软件的适配问题。\n\n### 解决字体本身产生的问题\n如果调整了屏幕缩放，文字依然模糊。那就需要解决字体问题了。替换字体有两种思路：\n1. 更换字体：用别的字体作为默认字体。 对系统造成的破坏最小，随时可以改回来。\n2. 修改字体：对默认的微软雅黑进行处理。 对微软雅黑进行处理，让它获得更好的视觉效果。\n全局更换字体的简单方法\n更换系统字体有许多方法，小软件、小工具也不少。这里推荐一个来自日本开发者的「全局字体更换」开源小工具：noMeiryoUI，noMeiryoUI 的特点是针对亚洲字符集字体做了优化。软件可以在 Github 链接 下载。\nnoMeiryoUI 的操作和使用都非常简单。你只需要事先找到并安装一个适合日常使用的字体，要避免选择缺胳膊少腿的字体，以免改完后出现许多 □ □ □。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203205101.png)\n\n然后就像在编辑器里修改字体一样，点击 `Select...` 直接指定系统全局所用的字体和字号大小。选择字体时，同一个字体可能会有多种字符集（简体、繁体、日语等），这在 noMeiryoUI 中可以单独选择。当然也可以分别对标题栏、图标、调色板标题、提示、消息框、菜单的字体和字号进行单独设置。\n然后选择` Set All `就可以替换完成。\n\n经过 noMeiryoUI 替换字体后，大部分 Win32 软件（包括系统软件在内）改变默认的字体和字号。noMeiryoUI 无需开在后台，一次替换就能长期使用。\n为了展现替换效果，我选择了和系统字体差别明显的幼圆字体。软件中采用 DirectWrite 渲染的部分文字是无法替换的，菜单则被完整替换了。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210357.png)\n\n### 修复字体 Hint 模糊的方法\n\n字体模糊的情况通常在采用 125% - 200% 缩放比例的情况下发生。所以修复微软雅黑、宋体等系统默认字体本身产生的模糊，也是一个可行的方案。\n上面讲到由于错误的 GASP 信息产生了不正确的 Hint，那么禁用 Hint 就能让文字变得更锐利一些。大致的思路是：使用批处理脚本处理系统默认字体的 GASP 信息、进入命令行模式（解除字体占用）、将处理后的字体覆盖原字体。\n这个操作与换一个字体作为系统字体不同，它会修改并替换系统字体文件本身，在未做备份的情况下替换字体可能会产生一些不可预料的后果（字体显示问题、蓝屏等）。所以安全性和兼容性比较一般，不是很推荐。不过它可以解决 DirectWrite 模式下的 Hint 模糊问题，需要的读者可以进入该链接按步骤操作。\n\n### 解决渲染时产生的模糊\n如果调整缩放、修改字体都没有缓解字体模糊，就需要采取一些其他手段来解决字体渲染引擎产生的模糊。\n\n#### 更换系统字体渲染引擎：MacType\n更改字体渲染引擎是一个庞大的工程，只要是有文字的地方就会用到字体渲染，牵一发而动全身，不得不慎重。\nWindows 上表现出色的字体渲染软件是 MacType，它可以帮助改善 Windows 中基于 GDI 的字体渲染，并支持热替换系统的默认宋体。你可以在它的 Github 链接 下载到 Beta 版本。\n\n#### MacType 的加载方式\n下载并安装后，MacType 会进入一个用户向导界面，你可以自主选择 MacType 的加载方式。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210526.png)\n\n这几种加载方式的优缺点已经在软件界面中详细说明，如果要概括一下：\n* 注册表加载：体验最好，开关需要重启系统。\n* 服务加载：平滑度较高，开关需要使用服务管理器。\n* 不使用自动加载：拖动到图标上加载，可以只针对特定渲染效果较差的软件修改。\n* MacTray 托盘独立加载：可以单独设置一些应用是否渲染。\n* MacTray 托盘兼容加载：兼容性最好。\n\n如果想要全局使用，我个人比较推荐服务加载，软件不会影响到注册表，停用时比较方便。\n如果只是想针对个别软件进行字体优化，则推荐 MacTray 托盘独立加载。\n这些加载方式各有优缺点，大家可以衡量一下自己对于美观度和稳定性的要求，来选择最适合自己的方法。\n\n#### MacType 的配置文件\n如果你不想做过多的配置，直接使用第二步中预设的默认配置文件，点击完成就配置完毕了。如果对这个配置的渲染效果不满意，可以多试几个，也可以自行配置文件。在网络上也有不少 MacType 相关的字体和配置文件。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210616.png)\n\n不过 MacType 的功效仍然是有限的，它不支持采用 DirectWrite 字体引擎的软件（主要是 UWP 应用）。你需要做更多的配置才能实现。\n\n#### MacType 的其他注意事项\n尽管 MacType 的效果已是十分喜人，但它作为第三方软件，仍然不可避免地出现一些问题。\n它的兼容性一般，它在大部分情况下都能正常运作，但在部分软件、游戏、驱动程序中会出现错误的文字渲染，比如一整行文字挤在一起。如果追求工作环境的稳定，则不建议使用 MacType。如果你在安装 MacType 之后，一些原先可以打开的软件忽然打不开了，一定要记得在 MacType 中排除这个软件。\n顺带一提，目前 Chrome 会默认开启 DirectWrite 且不可关闭，这种情况下使用 MacType 偶尔会产生冲突。网上有许多人求禁用 Chrome 中 DriectWrite 的方法，其实没有这个必要。只需要在 MacType 中关闭针对 Chrome 的渲染，并在 Chrome 中修改浏览器显示字体就可以了。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190203210828.png)\n\n## 小结\nWindows 的字体渲染问题并非是微软完全不作为，因为在的 Windows 10 1703 和 1809 中，字体方面都得到了小幅度的改进，微软雅黑这个字体本身也经历了多次迭代，还有传闻称今年四月份微软将会用兰亭黑体替换掉微软雅黑。但在目前，Windows 渲染效果差仍然是个不争的事实。\n文章对产生这个问题的原因进行了分析，显示器分辨率，系统默认字体，老的引擎难以淘汰、新的引擎未能覆盖……但只要对症下药，这些问题都是可以解决的。分别从分辨率、字体、渲染引擎几个角度下手，就能搞定 Windows 的字体渲染问题。\n\n\n","tags":["windows","字体","美化"],"categories":["教程"]},{"title":"Syncthing就是我要的同步备份软件","url":"/syncthing-the-best/","content":"\n[](#引言 \"引言\")引言\n--------------\n\n数据无价，平时不注意备份，电脑突然翻车就追悔莫及啦。\n\n最开始的时候，我在路由器上开启 Samba，每次编辑完项目就手动拷贝到路由器硬盘里，麻烦程度可想而知，后来又用了 Google Drive/One Drive，又因为它们的网络不理想，就又放弃使用了。\n\n其实就是很简单的需求，自动备份、速度快，然后去找了一下，发现一堆人推荐用 Rsync，这货我只在 VPS 上用过，拿来做镜像同步，但是要做实时同步，不好配置。\n\n我就想，这需求应该有一大堆人有吧，就去 github 搜索 sync，发现 Syncthing 这么个好东西，截止 2018-06-13 已经得到 20k+ 的 star，并且更新很活跃\n\n[](#介绍 \"介绍\")介绍\n--------------\n\n![logo](https://pic.zhih.me/blog/posts/syncthing-the-best/logo.jpg)\n\nSyncthing 是一个文件连续同步软件\n\n项目地址：[https://github.com/syncthing/syncthing](https://github.com/syncthing/syncthing)\n\n它有以下特性：\n\n*   跨平台\n    \n    *   使用 Golang 开发，几乎能在所有平台上使用，包括常见的安卓手机和路由器平台\n*   易于使用\n    \n    *   只需要下载运行，打开浏览设置本地目录和远程主机，其他的不需要管\n*   安全\n    \n    *   管理页可以设置密码，可以设置 https，设置备份需要两边都确认，使用唯一设备标识进行确认\n\n[](#安装 \"安装\")安装\n--------------\n\nSyncthing 有多种安装方式\n\n有一定 Linux 基础的人，可以使用下面的配置来设置启动服务\n\n*   [https://github.com/syncthing/syncthing/tree/master/etc](https://github.com/syncthing/syncthing/tree/master/etc)\n\nWindows，Mac，Linux 和安卓手机可以在这里下载有 GUI 界面的程序使用\n\n*   [https://docs.syncthing.net/users/contrib.html#gui-wrappers](https://docs.syncthing.net/users/contrib.html#gui-wrappers)\n\n其他方法可以自己决定，我是直接下载安装包命令行启动的\n\n### [](#在-MacOS-上安装 \"在 MacOS 上安装\")在 MacOS 上安装\n\n我用的是 MacOS，可以直接使用 homebrew 安装启动，并且可以开机自动启动，你也可以到这里 [QSyncthingTray](https://github.com/sieren/QSyncthingTray/releases) 下载 MacOS 的 GUI 版\n\n```\nbrew install syncthing  \n```\n\n启动服务（同时设置开机启动）\n\n```\nbrew services start syncthing  \n```\n\n停止服务（同时关闭自启）\n\n```\nbrew services stop syncthing  \n```\n\n手动启动（不会开机自启）\n\n```\nsyncthing  \n```\n\n启动进程后，可以用浏览器打开 `http://localhost:8384/` 来查看 web 管理页\n\n### [](#在-Windows-上安装 \"在 Windows 上安装\")在 Windows 上安装\n\nWindows 直接在这里 [SyncTrayzor](https://github.com/canton7/SyncTrayzor/releases) 下载软件运行\n\n### [](#在-Linux-VPS-上安装 \"在 Linux VPS 上安装\")在 Linux VPS 上安装\n\n大多数发行版和不同 CPU 平台的安装包，可以在这里 [Syncthing](https://github.com/syncthing/syncthing/releases) 找到，把它下载到你想要放在的目录然后设置权限，使用命令运行\n\n文章开头有 GUI 版本的链接，不过我要装在没有 GUI 的 VPS 上，所以直接用命令行运行，系统用的是 Debian 9，然后用 supervisor 进程守护来启动的\n\n碰巧前几天之前的一个客户，他的 VPS 做迁移，阿里云送了张代金券，然后客户就送给我了\n\n![aff](https://pic.zhih.me/blog/posts/syncthing-the-best/aff.jpg)\n\n然后续费 9 个月的阿里云学生机，美滋滋😎\n\n虽然带宽比较低，但是对于这种连续同步的备份来说，在第一次备份之后，后面都是增量备份了，除非你都是备份大文件，要不对带宽的要求不是很高，另外 40G 的盘，完全够我备份用了，阿里云最主要就是稳定，很适合做我的备份机\n\n#### [](#下载-Syncthing \"下载 Syncthing\")下载 Syncthing\n\n下载最新的包，解压，移动到 `/bin/` 里，改权限\n\n```\nwget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \ntar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \nmv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /bin/  \n  \nchmod +x /bin/syncthing  \n```\n\n#### [](#进程守护 \"进程守护\")进程守护\n\n安装 supervisor\n\n```\napt-get install supervisor  \n```\n\n配置守护\n\n```\nvi /etc/supervisor/conf.d/syncthing.conf  \n```\n\n填入以下内容\n\n```\n\\[program:syncthing\\]  \ncommand = /bin/syncthing -no-browser -home=\"/root/.config/syncthing\"  \ndirectory = /root  \nautorestart = True  \nuser = root  \nenvironment = STNORESTART=\"1\", HOME=\"/root\"  \n```\n\n**注意**，我例子里使用的是 root 用户，所以响应的目录是 `/root`，你要是使用其他用户，应该是 `/home/用户名`，就是你登录时默认所在的目录\n\n现在就可以使用 `supervisorctl` 命令来管理进程了\n\n*   启动\n\n```\nsupervisorctl start syncthing  \n```\n\n*   重启\n\n```\nsupervisorctl restart syncthing  \n```\n\n*   停止\n\n```\nsupervisorctl stop syncthing  \n```\n\n启动进程后，可以用浏览器打开 `http://你的IP:8384/` 来查看 web 管理页\n\n如果无法打开页面，需要修改 `/.config/syncthing/config.xml` 里的 `127.0.0.1:8384` 字段为 `0.0.0.0:8384`，或者你可以和我一样使用 nginx 做反向代理，前提是你知道怎么做\n\n### [](#在路由器上安装 \"在路由器上安装\")在路由器上安装\n\n目前 [Entware](https://entware.net/) 源里已经有这个包了，但是我发现它是个旧版本，并且有问题，所以这里我选择手动安装\n\n这里的例子是 LEDE x64 但是也适合一切安装了 Entware 的路由器\n\n在这里 [Syncthing](https://github.com/syncthing/syncthing/releases) 下载对应 CPU 平台的安装包，可以用 `uname -m` 查看，我这里是 x86_64 所以选择 amd64\n\n#### [](#下载-syncthing \"下载 syncthing\")下载 syncthing\n\n下载最新的包，解压，移动到 `/opt/bin/` 里，改权限\n```\nwget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \ntar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz  \n  \nmv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /opt/bin/  \n  \nchmod +x /opt/bin/syncthing  \n```\n#### [](#添加启动命令 \"添加启动命令\")添加启动命令\n\n创建并编辑 `/opt/etc/init.d/S92syncthing`\n```\nvi /opt/etc/init.d/S92syncthing  \n```\n在里面填上下面所有字段\n\n```\n #!/bin/sh  \nENABLED=yes  \nPROCS=syncthing  \nARGS=\"-home=/opt/etc/syncthing\"  \nPREARGS=\"\"  \nDESC=$PROCS  \nPATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin  \n  \nif \\[ ! -d /opt/etc/syncthing \\]; then  \n /opt/bin/syncthing -generate=\"/opt/etc/syncthing\"  \n sed -i 's|127.0.0.1:8384|0.0.0.0:8384|' /opt/etc/syncthing/config.xml  \nelif \\[\\[ -f /opt/etc/syncthing/config.xml -a \"127.0.0.1:8384\"==\"127.0.0.1:8384\" \\]\\]; then  \n sed -i 's|127.0.0.1:8384|0.0.0.0:8384|' /opt/etc/syncthing/config.xml  \nfi  \n  \n. /opt/etc/init.d/rc.func  \n```\n然后给权限\n```\nchmod +x /opt/etc/init.d/S92syncthing  \n```\n用法: /opt/etc/init.d/S92syncthing (start|stop|restart|check)\n\n启动服务就能在浏览器打开 `路由器IP:8384` 例如 `192.168.1.1:8384` 打开管理页了\n\n[](#使用方法 \"使用方法\")使用方法\n--------------------\n\n易于使用是 Syncthing 的一个重要特性，打开管理页，一目了然\n\n首次打开管理页，所有平台上都是一样的\n\n![syncthing](https://pic.zhih.me/blog/posts/syncthing-the-best/syncthing.jpg)\n\n然后你需要做的就是\n\n### [](#设置用户名、密码 \"设置用户名、密码\")设置用户名、密码\n\n![setpass](https://pic.zhih.me/blog/posts/syncthing-the-best/setpass.jpg)\n\n### [](#设置文件夹 \"设置文件夹\")设置文件夹\n\n删除默认的同步文件夹，添加新同步文件夹\n\n![addlocal](https://pic.zhih.me/blog/posts/syncthing-the-best/addlocal.jpg)\n\n### [](#添加远程设备 \"添加远程设备\")添加远程设备\n\n![addremote](https://pic.zhih.me/blog/posts/syncthing-the-best/addremote.jpg)\n\n然后稍微等一分钟，两边就能连接上了\n\n最终效果\n\n![end](https://pic.zhih.me/blog/posts/syncthing-the-best/end.jpg)\n\n[](#结语 \"结语\")结语\n--------------\n\nSyncthing 作为一款跨平台同步软件，它简单易用、功能完善强大，具有很高的稳定性，很容易让人想出各种使用场景，而且它还是开源的，感谢那上百位贡献者\n\n本文简单介绍了初级使用方法，还未提及其他的诸如版本控制等功能，其他功能应用，如果以后我觉得值得一说，再更新了\n\n","tags":["syncthing","备份","软件"],"categories":["好软推荐"]},{"title":"MacOS上虚拟环境安装TensorFlow","url":"/TensorFlow/","content":"\n# MacOS上虚拟环境安装TensorFlow\n\n\n## 0x1 检查是否已经配置Python环境\n\n注意MacOS系统上只支持CPU的TensorFlow，而且对系统安装的Python版本有要求，仅支持以下Python版本。\n\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124115513.png)\n\n\n```\npython3 --version\npip3 --version\nvirtualenv --version\n```\n\n如果已安装这些软件包，请跳至下一步。\n否则，请安装 Python、pip 软件包管理器和 Virtualenv：\n\n安装方式：\n首先安装Python3.6，可以去官网下载安装包或者通过homebrew安装\n下面介绍通过Homebrew安装方式\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nexport PATH=\"/usr/local/bin:/usr/local/sbin:$PATH\"\nbrew update\nbrew install python  # Python 3\nsudo pip3 install -U virtualenv  # system-wide install\n```\n\n## 0x2 创建虚拟环境\n**1、创建一个新的虚拟环境**，方法是选择 Python 解释器并创建一个 `./venv` 目录来存放它：\n```\nvirtualenv --system-site-packages -p python3 ./venv\n```\n如果这里出错了，提示`bash: virtualenv command not found`\n需要在编辑器中添加一个执行virtualenv的路径\n```\n    vim ~/.zshrc\n ```   \n编辑配置文件，加一行Python3.6的路径\n``` \n    export PATH=/Library/Frameworks/Python.framework/Versions/3.6/bin:$PATH\n```    \n:wq保存后记得激活下配置文件\n```\n    source ~/.zshrc    \n```    \n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124120831.png)\n\n**2、使用特定于 shell 的命令激活该虚拟环境：**\n创建好虚拟环境后，需要激活下环境\n```\n    source ./venv/bin/activate  # sh, bash, ksh, or zsh\n```   \n\n## 0x3 虚拟环境安装软件包\n\n当 virtualenv 处于有效状态时，shell 提示符带有 (venv) 前缀。\n![](https://geekmubai-1253861834.cos.ap-shanghai.myqcloud.com/20190124121318.png)\n在不影响主机系统设置的情况下，在虚拟环境中安装软件包。首先升级 pip：\n```\n    pip install --upgrade pip\n    pip list  # 显示虚拟环境中安装的软件包\n```    \n之后要退出 virtualenv，请使用以下命令：\n```\n    deactivate  # 不要退出虚拟环境，直到你使用完TensorFlow\n```    \n    \n**安装 TensorFlow pip 软件包**\n```\n    pip install --upgrade tensorflow\n```\n验证安装效果\n```\n    python -c \"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))\"\n```","tags":["TensorFlow","Python","人工智能"],"categories":["Python"]},{"title":"Python科学计算：用NumPy快速处理数据","url":"/Numpy/","content":"# Python科学计算：用NumPy快速处理数据\n\n![](https://static001.geekbang.org/resource/image/28/50/284d3ab3a036a1617bb93bb09ef6d650.jpg)\n\nPython中一个非常重要的第三方库就是NumPy。\n\n它不仅是Python中使用最多的第三方库，而且还是SciPy、Pandas等数据科学的基础库。它所提供的数据结构比Python自身的“更高级、更高效”，可以这么说，NumPy所提供的数据结构是Python数据分析的基础。\n\n我上次讲到了Python数组结构中的列表list，它实际上相当于一个数组的结构。而NumPy中一个关键数据类型就是关于数组的，那为什么还存在这样一个第三方的数组结构呢？\n\n实际上，标准的Python中，用列表list保存数组的数值。由于列表中的元素可以是任意的对象，所以列表中list保存的是对象的指针。虽然在Python编程中隐去了指针的概念，但是数组有指针，Python的列表list其实就是数组。这样如果我要保存一个简单的数组\\[0,1,2\\]，就需要有3个指针和3个整数的对象，这样对于Python来说是非常不经济的，浪费了内存和计算时间。\n\n使用NumPy让你的Python科学计算更高效\n-----------------------\n\n为什么要用NumPy数组结构而不是Python本身的列表list？这是因为列表list的元素在系统内存中是分散存储的，而NumPy数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表list还需要对内存地址进行查找，从而节省了计算资源。\n\n另外在内存访问模式中，缓存会直接把字节块从RAM加载到CPU寄存器中。因为数据连续的存储在内存中，NumPy直接利用现代CPU的矢量化指令计算，加载寄存器中的多个连续浮点数。另外NumPy中的矩阵计算可以采用多线程的方式，充分利用多核CPU计算资源，大大提升了计算效率。\n\n当然除了使用NumPy外，你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是：**避免采用隐式拷贝，而是采用就地操作的方式**。举个例子，如果我想让一个数值x是原来的两倍，可以直接写成x*=2，而不要写成y=x*2。\n\n这样速度能快到2倍甚至更多。\n\n既然NumPy这么厉害，你该从哪儿入手学习呢？在NumPy里有两个重要的对象：ndarray（N-dimensional array object）解决了多维数组问题，而ufunc（universal function object）则是解决对数组进行处理的函数。下面，我就带你一一来看。\n\n**ndarray对象**\n\nndarray实际上是多维数组的含义。在NumPy数组中，维数称为秩（rank），一维数组的秩为1，二维数组的秩为2，以此类推。在NumPy中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。\n\n下面，你来看ndarray对象是如何创建数组的，又是如何处理结构数组的呢？\n\n**创建数组**\n\n    import numpy as np\n    a = np.array([1, 2, 3])\n    b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    b[1,1]=10\n    print a.shape\n    print b.shape\n    print a.dtype\n    print b\n    \n\n运行结果：\n\n    (3L,)\n    (3L, 3L)\n    int32\n    [[ 1  2  3]\n     [ 4 10  6]\n     [ 7  8  9]]\n    \n\n创建数组前，你需要引用NumPy库，可以直接通过array函数创建数组，如果是多重数组，比如示例里的b，那么该怎么做呢？你可以先把一个数组作为一个元素，然后嵌套起来，比如示例b中的\\[1,2,3\\]就是一个元素，然后\\[4,5,6\\]\\[7,8,9\\]也是作为元素，然后把三个元素再放到\\[\\]数组里，赋值给变量b。\n\n当然数组也是有属性的，比如你可以通过函数shape属性获得数组的大小，通过dtype获得元素的属性。如果你想对数组里的数值进行修改的话，直接赋值即可，注意下标是从0开始计的，所以如果你想对b数组，九宫格里的中间元素进行修改的话，下标应该是\\[1,1\\]。\n\n**结构数组**\n\n如果你想统计一个班级里面学生的姓名、年龄，以及语文、英语、数学成绩该怎么办？当然你可以用数组的下标来代表不同的字段，比如下标为0的是姓名、小标为1的是年龄等，但是这样不显性。\n\n实际上在C语言里，可以定义结构数组，也就是通过struct定义结构类型，结构中的字段占据连续的内存空间，每个结构体占用的内存大小都相同，那在NumPy中是怎样操作的呢？\n\n    import numpy as np\n    persontype = np.dtype({\n        'names':['name', 'age', 'chinese', 'math', 'english'],\n        'formats':['S32','i', 'i', 'i', 'f']})\n    peoples = np.array([(\"ZhangFei\",32,75,100, 90),(\"GuanYu\",24,85,96,88.5),\n           (\"ZhaoYun\",28,85,92,96.5),(\"HuangZhong\",29,65,85,100)],\n        dtype=persontype)\n    ages = peoples[:]['age']\n    chineses = peoples[:]['chinese']\n    maths = peoples[:]['math']\n    englishs = peoples[:]['english']\n    print np.mean(ages)\n    print np.mean(chineses)\n    print np.mean(maths)\n    print np.mean(englishs)\n    \n\n运行结果：\n\n    28.25\n    77.5\n    93.25\n    93.75\n    \n\n你看下这个例子，首先在NumPy中是用dtype定义的结构类型，然后在定义数组的时候，用array中指定了结构数组的类型dtype=persontype，这样你就可以自由地使用自定义的persontype了。比如想知道每个人的语文成绩，就可以用chineses = peoples\\[:\\]\\[‘chinese’\\]，当然NumPy中还有一些自带的数学运算，比如计算平均值使用np.mean。\n\n**ufunc运算**\n\nufunc是universal function的缩写，是不是听起来就感觉功能非常强大？确如其名，它能对数组中每个元素进行函数操作。NumPy中很多ufunc函数计算速度非常快，因为都是采用C语言实现的。\n\n**连续数组的创建**\n\nNumPy可以很方便地创建连续数组，比如我使用arange或linspace函数进行创建：\n\n    x1 = np.arange(1,11,2)\n    x2 = np.linspace(1,9,5)\n    \n\nnp.arange和np.linspace起到的作用是一样的，都是创建等差数组。这两个数组的结果x1,x2都是\\[1 3 5 7 9\\]。结果相同，但是你能看出来创建的方式是不同的。\n\narange()类似内置函数range()，通过指定**初始值、终值、步长**来创建等差数列的一维数组，默认是不包括终值的。\n\nlinspace是linear space的缩写，代表线性等分向量的含义。linspace()通过指定**初始值、终值、元素个数**来创建等差数列的一维数组，默认是包括终值的。\n\n**算数运算**\n\n通过NumPy可以自由地创建等差数组，同时也可以进行加、减、乘、除、求n次方和取余数。\n\n    x1 = np.arange(1,11,2)\n    x2 = np.linspace(1,9,5)\n    print np.add(x1, x2)\n    print np.subtract(x1, x2)\n    print np.multiply(x1, x2)\n    print np.divide(x1, x2)\n    print np.power(x1, x2)\n    print np.remainder(x1, x2)\n    \n\n运行结果：\n\n    [ 2.  6. 10. 14. 18.]\n    [0. 0. 0. 0. 0.]\n    [ 1.  9. 25. 49. 81.]\n    [1. 1. 1. 1. 1.]\n    [1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05\n     3.87420489e+08]\n    [0. 0. 0. 0. 0.]\n    \n\n我还以x1, x2数组为例，求这两个数组之间的加、减、乘、除、求n次方和取余数。在n次方中，x2数组中的元素实际上是次方的次数，x1数组的元素为基数。\n\n在取余函数里，你既可以用np.remainder(x1, x2)，也可以用np.mod(x1, x2)，结果是一样的。\n\n**统计函数**\n\n如果你想要对一堆数据有更清晰的认识，就需要对这些数据进行描述性的统计分析，比如了解这些数据中的最大值、最小值、平均值，是否符合正态分布，方差、标准差多少等等。它们可以让你更清楚地对这组数据有认知。\n\n下面我来介绍下在NumPy中如何使用这些统计函数。\n\n**计数组/矩阵中的最大值函数amax()，最小值函数amin()**\n\n    import numpy as np\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.amin(a)\n    print np.amin(a,0)\n    print np.amin(a,1)\n    print np.amax(a)\n    print np.amax(a,0)\n    print np.amax(a,1)\n    \n\n运行结果：\n\n    1\n    [1 2 3]\n    [1 4 7]\n    9\n    [7 8 9]\n    [3 6 9]\n    \n\namin() 用于计算数组中的元素沿指定轴的最小值。对于一个二维数组a，amin(a)指的是数组中全部元素的最小值，amin(a,0)是延着axis=0轴的最小值，axis=0轴是把元素看成了\\[1,2,3\\], \\[4,5,6\\], \\[7,8,9\\]三个元素，所以最小值为\\[1,2,3\\]，amin(a,1)是延着axis=1轴的最小值，axis=1轴是把元素看成了\\[1,4,7\\], \\[2,5,8\\], \\[3,6,9\\]三个元素，所以最小值为\\[1,4,7\\]。同理amax()是计算数组中元素沿指定轴的最大值。\n\n**统计最大值与最小值之差 ptp()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.ptp(a)\n    print np.ptp(a,0)\n    print np.ptp(a,1)\n    \n\n运行结果：\n\n    8\n    [6 6 6]\n    [2 2 2]\n    \n\n对于相同的数组a，np.ptp(a)可以统计数组中最大值与最小值的差，即9-1=8。同样ptp(a,0)统计的是沿着axis=0轴的最大值与最小值之差，即7-1=6（当然8-2=6,9-3=6，第三行减去第一行的ptp差均为6），ptp(a,1)统计的是沿着axis=1轴的最大值与最小值之差，即3-1=2（当然6-4=2, 9-7=2，即第三列与第一列的ptp差均为2）。\n\n**统计数组的百分位数 percentile()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    print np.percentile(a, 50)\n    print np.percentile(a, 50, axis=0)\n    print np.percentile(a, 50, axis=1)\n    \n\n运行结果：\n\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    \n\n同样，percentile()代表着第 p 个百分位数，这里p的取值范围是0-100，如果p=0，那么就是求最小值，如果p=50就是求平均值，如果p=100就是求最大值。同样你也可以求得在axis=0 和 axis=1两个轴上的p%的百分位数。\n\n**统计数组中的中位数median()、平均数mean()**\n\n    a = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    #求中位数\n    print np.median(a)\n    print np.median(a, axis=0)\n    print np.median(a, axis=1)\n    #求平均数\n    print np.mean(a)\n    print np.mean(a, axis=0)\n    print np.mean(a, axis=1)\n    \n\n运行结果：\n\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    5.0\n    [4. 5. 6.]\n    [2. 5. 8.]\n    \n\n你可以用median()和mean()求数组的中位数、平均值，同样也可以求得在axis=0和1两个轴上的中位数、平均值。你可以自己练习下看看运行结果。\n\n**统计数组中的加权平均值average()**\n\n    a = np.array([1,2,3,4])\n    wts = np.array([1,2,3,4])\n    print np.average(a)\n    print np.average(a,weights=wts)\n    \n\n运行结果：\n\n    2.5\n    3.0\n    \n\naverage()函数可以求加权平均，加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的，所以np.average(a)=(1+2+3+4)/4=2.5，你也可以指定权重数组wts=\\[1,2,3,4\\]，这样加权平均np.average(a,weights=wts)=(1\\*1+2\\*2+3\\*3+4\\*4)/(1+2+3+4)=3.0。\n\n**统计数组中的标准差std()、方差var()**\n\n    a = np.array([1,2,3,4])\n    print np.std(a)\n    print np.var(a)\n    \n\n运行结果：\n\n    1.118033988749895\n    1.25\n    \n\n方差的计算是指每个数值与平均值之差的平方求和的平均值，即mean((x - x.mean())** 2)。标准差是方差的算术平方根。在数学意义上，代表的是一组数据离平均值的分散程度。所以np.var(a)=1.25, np.std(a)=1.118033988749895。\n\n**NumPy排序**\n\n排序是算法中使用频率最高的一种，也是在数据分析工作中常用的方法，计算机专业的同学会在大学期间的算法课中学习。\n\n那么这些排序算法在NumPy中实现起来其实非常简单，一条语句就可以搞定。这里你可以使用sort函数，sort(a, axis=-1, kind=‘quicksort’, order=None)，默认情况下使用的是快速排序；在kind里，可以指定quicksort、mergesort、heapsort分别表示快速排序、合并排序、堆排序。同样axis默认是-1，即沿着数组的最后一个轴进行排序，也可以取不同的axis轴，或者axis=None代表采用扁平化的方式作为一个向量进行排序。另外order字段，对于结构化的数组可以指定按照某个字段进行排序。\n\n    a = np.array([[4,3,2],[2,4,1]])\n    print np.sort(a)\n    print np.sort(a, axis=None)\n    print np.sort(a, axis=0)  \n    print np.sort(a, axis=1)  \n    \n\n运行结果：\n\n    [[2 3 4]\n     [1 2 4]]\n    [1 2 2 3 4 4]\n    [[2 3 1]\n     [4 4 2]]\n    [[2 3 4]\n     [1 2 4]]\n    \n\n你可以自己计算下这个运行结果，然后再跑一遍比对下。\n\n总结\n--\n\n在NumPy学习中，你重点要掌握的就是对数组的使用，因为这是NumPy和标准Python最大的区别。在NumPy中重新对数组进行了定义，同时提供了算术和统计运算，你也可以使用NumPy自带的排序功能，一句话就搞定各种排序算法。\n\n当然要理解NumPy提供的数据结构为什么比Python自身的“更高级、更高效”，要从对数据指针的引用角度进行理解。\n\n![](https://static001.geekbang.org/resource/image/7b/66/7ba74ca7776ac29a5dc94c272d72ff66.jpg)  \n","tags":["Python","NumPy","数据科学"],"categories":["Python"]}]